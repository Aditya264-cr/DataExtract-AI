
import React, { useState, useCallback, useMemo, useEffect, useRef, useContext } from 'react';
import type { ExtractedData, OutputFormat, UploadedFile, AISummaryData } from '../../types';
import { generateSummaryFromData, getExplanationForField } from '../../services/geminiService';
import { autoFormatValue, validateDocumentLogic } from '../../utils/validationUtils';
import { SettingsContext } from '../../contexts/SettingsContext';
import { useClickOutside } from '../../hooks/useClickOutside';
import { AISummary } from '../AISummary';
import { SaveTemplateModal } from '../ui/SaveTemplateModal';
import { ArrowDownTrayIcon } from '../icons/ArrowDownTrayIcon';
import { ClipboardDocumentIcon } from '../icons/ClipboardDocumentIcon';
import { ChevronDownIcon } from '../icons/ChevronDownIcon';
import { BoldIcon } from '../icons/BoldIcon';
import { ItalicIcon } from '../icons/ItalicIcon';
import { ListBulletIcon } from '../icons/ListBulletIcon';
import { UnderlineIcon } from '../icons/UnderlineIcon';
import { StrikethroughIcon } from '../icons/StrikethroughIcon';
import { ListOrderedIcon } from '../icons/ListOrderedIcon';
import { ClearFormattingIcon } from '../icons/ClearFormattingIcon';
import { ExplanationModal } from '../ui/ExplanationModal';
import { LightBulbIcon } from '../icons/LightBulbIcon';
import { CheckCircleIcon } from '../icons/CheckCircleIcon';
import { Tooltip } from '../ui/Tooltip';
import { CodeBracketIcon } from '../icons/CodeBracketIcon';
import { TableCellsIcon } from '../icons/TableCellsIcon';
import { DocumentTextIcon } from '../icons/DocumentTextIcon';
import { PhotoIcon } from '../icons/PhotoIcon';
import { ViewColumnsIcon } from '../icons/ViewColumnsIcon';
import { ExclamationTriangleIcon } from '../icons/ExclamationTriangleIcon';
import { DocumentHighlighter } from '../DocumentHighlighter';
import { ShieldCheckIcon } from '../icons/ShieldCheckIcon';
import { flattenObject, extractTables, updateNestedState, updateTableData, DiscoveredTable } from '../../utils/dataAdapter';
import { formatAsOfficialDocument } from '../../utils/textFormatter';
import { MagnifyingGlassIcon } from '../icons/MagnifyingGlassIcon';
import { XMarkIcon } from '../icons/XMarkIcon';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import html2canvas from 'html2canvas';
import * as XLSX from 'xlsx';
import { Notification } from '../ui/Notification';
import { logAuditEvent, getAuditLog, generateApprovalStamp, ApprovalStamp } from '../../utils/auditLogger';

interface CenterWorkspaceProps {
    data: ExtractedData;
    file: UploadedFile;
    onNewUpload: () => void;
    onReprocess: (editedData: ExtractedData) => void;
}

const WATERMARK_TEXT = "Generated by DataExtract AI";

const outputFormats: { id: OutputFormat; label: string; tooltip: string }[] = [
    { id: 'key_value', label: 'Key-Value', tooltip: 'Flat data mapping' },
    { id: 'grid', label: 'Grid', tooltip: 'Tabular spreadsheet view' },
    { id: 'text', label: 'Report', tooltip: 'Official document text' },
    { id: 'json', label: 'JSON', tooltip: 'Raw technical structure' },
];

const downloadOptions = [
    { format: 'json', label: 'JSON File', description: 'Raw structured data', icon: CodeBracketIcon },
    { format: 'xlsx', label: 'Excel (XLSX)', description: 'Formatted spreadsheet', icon: TableCellsIcon },
    { format: 'csv', label: 'CSV Sheet', description: 'Comma separated values', icon: TableCellsIcon },
    { format: 'txt', label: 'Report Text', description: 'Official text format', icon: DocumentTextIcon },
    { format: 'pdf', label: 'PDF Report', description: 'Visual summary', icon: DocumentTextIcon },
    { format: 'png', label: 'PNG Image', description: 'Screenshot of results', icon: PhotoIcon },
];

const ConfidenceBadge: React.FC<{ score: number | undefined }> = ({ score }) => {
    if (score === undefined) return null;
    let colorClass = 'bg-[#FF3B30] text-white'; 
    if (score >= 85) colorClass = 'bg-[#34C759] text-white';
    else if (score >= 60) colorClass = 'bg-[#FF9500] text-white'; 

    return (
        <span className={`inline-flex items-center px-1.5 py-0.5 rounded-full text-[10px] font-bold ${colorClass} ml-2 flex-shrink-0 animate-fade-in`}>
            {score}%
        </span>
    );
};

const EditableInput = ({ 
    value, onChange, onBlur, label, onFocus, isActive, isEdited, className, disabled 
}: { 
    value: string; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void; label: string; onFocus?: () => void; isActive?: boolean; isEdited?: boolean; className?: string; disabled?: boolean;
}) => (
    <input
        type="text"
        value={value}
        onChange={onChange}
        onFocus={onFocus}
        onBlur={onBlur}
        aria-label={label}
        disabled={disabled}
        className={`w-full bg-transparent p-0 m-0 border-none focus:ring-1 focus:ring-blue-500 focus:bg-blue-500/10 rounded-md px-1 dark:text-gray-200 cursor-pointer transition-all ${isActive ? 'bg-blue-500/20 ring-2 ring-blue-500 ring-offset-2 dark:ring-offset-zinc-800' : ''} ${isEdited ? 'bg-yellow-100 dark:bg-yellow-500/20' : ''} ${disabled ? 'cursor-not-allowed opacity-70 text-gray-500 italic' : ''} ${className || ''}`}
    />
);

const prepareDataForTable = (data: any[]) => {
    return data.map((row: any) => {
        const newRow: any = {};
        for (const key in row) {
            const val = row[key];
            newRow[key] = (typeof val === 'object' && val !== null) ? JSON.stringify(val) : val;
        }
        return newRow;
    });
};

export const CenterWorkspace: React.FC<CenterWorkspaceProps> = ({ data, file, onNewUpload, onReprocess }) => {
    const { settings } = useContext(SettingsContext);
    const [activeFormat, setActiveFormat] = useState<OutputFormat>('key_value');
    const [copied, setCopied] = useState(false);
    const [editedData, setEditedData] = useState<ExtractedData>(data);
    const [editedFields, setEditedFields] = useState(new Set<string>());
    const [isDownloadOpen, setIsDownloadOpen] = useState(false);
    const [isTemplateModalOpen, setIsTemplateModalOpen] = useState(false);
    const [textContent, setTextContent] = useState('');
    const [isTextDirty, setIsTextDirty] = useState(false);
    const [summary, setSummary] = useState<AISummaryData | null>(null);
    const [isSummaryLoading, setIsSummaryLoading] = useState<boolean>(true);
    const [activeField, setActiveField] = useState<string | null>(null);
    const [isApproved, setIsApproved] = useState(false);
    const [approvalStamp, setApprovalStamp] = useState<ApprovalStamp | null>(null);
    const [notification, setNotification] = useState<{ message: string; type: 'success' | 'error' | 'info'; action?: any } | null>(null);
    const [isExplanationModalOpen, setIsExplanationModalOpen] = useState(false);
    const [explanationTarget, setExplanationTarget] = useState<{ fieldName: string; fieldValue?: string } | null>(null);
    const [explanationContent, setExplanationContent] = useState<string | null>(null);
    const [isExplanationLoading, setIsExplanationLoading] = useState(false);
    const [showSplitView, setShowSplitView] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [showOnlyIssues, setShowOnlyIssues] = useState(false);
    
    // Table Discovery State
    const [activeTableIndex, setActiveTableIndex] = useState(0);
    const tables = useMemo(() => extractTables(editedData.data), [editedData.data]);

    const tableRef = useRef<HTMLTableElement>(null);
    const editorRef = useRef<HTMLDivElement>(null);
    const downloadMenuRef = useRef<HTMLDivElement>(null);
    const resultsContentRef = useRef<HTMLDivElement>(null);

    const validationResult = useMemo(() => validateDocumentLogic(editedData.data), [editedData.data]);
    
    useClickOutside(downloadMenuRef, () => {
        if (isDownloadOpen) setIsDownloadOpen(false);
    });

    // Reset table index if data structure changes significantly
    useEffect(() => {
        if (activeTableIndex >= tables.length && tables.length > 0) {
            setActiveTableIndex(0);
        }
    }, [tables.length, activeTableIndex]);
    
    useEffect(() => {
        setSearchQuery('');
        setShowOnlyIssues(false);
    }, [activeFormat]);

    const confidenceMap = useMemo(() => {
        const map = new Map<string, number>();
        data.highlights?.forEach(h => { map.set(h.fieldName, h.confidence); });
        return map;
    }, [data.highlights]);

    const handleKeyValueChange = (flattenedKey: string, value: string) => {
        setEditedData(prev => {
            const isArray = Array.isArray(prev.data);
            const currentDataObj = isArray ? { ...prev.data[0] } : { ...prev.data };
            const updatedObj = updateNestedState(currentDataObj, flattenedKey, value);
            const finalData = isArray ? [updatedObj, ...prev.data.slice(1)] : updatedObj;
            return { ...prev, data: finalData };
        });
        setEditedFields(prev => new Set(prev).add(flattenedKey));
        
        logAuditEvent('EDIT', settings.systemMode, {
            documentId: data.documentType,
            fieldsEdited: [flattenedKey],
            newValue: value
        });
        
        if (isApproved) {
            setIsApproved(false);
            setApprovalStamp(null);
            setNotification({ message: "Changes detected. Please re-approve.", type: 'info' });
        }
    };

    const handleGridChange = (rowIndex: number, key: string, value: string) => {
        const currentTable = tables[activeTableIndex];
        if (!currentTable) return;

        setEditedData(prev => {
            const newData = updateTableData(prev.data, currentTable.path, rowIndex, key, value);
            return { ...prev, data: newData };
        });
        const cellKey = `${currentTable.path || 'root'}-${rowIndex}-${key}`;
        setEditedFields(prev => new Set(prev).add(cellKey));

        logAuditEvent('EDIT', settings.systemMode, {
            documentId: data.documentType,
            fieldsEdited: [cellKey],
            newValue: value
        });

        if (isApproved) {
            setIsApproved(false);
            setApprovalStamp(null);
            setNotification({ message: "Changes detected. Please re-approve.", type: 'info' });
        }
    };

    const handleInputBlur = (key: string, value: string, rowIndex?: number) => {
        const formatted = autoFormatValue(key, value);
        if (formatted !== value) {
            if (rowIndex !== undefined) {
                handleGridChange(rowIndex, key, formatted);
            } else {
                handleKeyValueChange(key, formatted);
            }
            setNotification({ message: 'Auto-formatted value for consistency', type: 'info' });
        }
    };

    const handleApprove = () => {
        const errors = validationResult.issues.filter(i => i.severity === 'error').length;
        const warnings = validationResult.issues.filter(i => i.severity === 'warning').length;

        if (settings.systemMode === 'ENTERPRISE' && errors > 0) {
             setNotification({ message: "Cannot approve document with critical validation errors in Enterprise Mode.", type: 'error' });
             return;
        }

        const stamp = generateApprovalStamp(settings.systemMode, errors, warnings);
        setApprovalStamp(stamp);
        setIsApproved(true);
        logAuditEvent('APPROVE', settings.systemMode, { 
            validationSummary: { errors, warnings } 
        });
        setNotification({ message: "Document Approved & Locked", type: 'success' });
    };

    const generateTextSummary = useCallback((dataToSummarize: ExtractedData, currentActiveField: string | null): string => {
        const titleCase = (str: string) => str.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
        const dateStr = new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
        
        let html = `<div style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; line-height: 1.6; color: inherit;">`;
        
        // Header
        html += `<h1 style="font-size: 1.25em; font-weight: 800; margin-bottom: 0.5em; text-transform: uppercase;">${dataToSummarize.documentType}</h1>`;
        html += `<div style="opacity: 0.5; margin-bottom: 1em;">------------------------------------</div>`;
        html += `<div style="margin-bottom: 1.5em;">Date: ${dateStr}<br/>Confidence Score: ${dataToSummarize.confidenceScore}%</div>`;

        const createValueSpan = (key: string, val: any) => {
            const strVal = String(val);
            const isActive = currentActiveField === key;
            const bgClass = isActive ? 'background-color: rgba(255, 215, 0, 0.3);' : '';
            return `<span data-field-name="${key}" style="${bgClass} cursor: pointer; text-decoration: underline; text-decoration-style: dotted; text-decoration-color: rgba(100,100,100,0.5);">${strVal}</span>`;
        };

        const process = (obj: any, indentLevel: number = 0, pathPrefix: string = '') => {
            const indent = "&nbsp;".repeat(indentLevel * 4);
            
            if (Array.isArray(obj)) {
                obj.forEach((item, idx) => {
                    if (typeof item === 'object' && item !== null) {
                        html += `<div>${indent}${idx + 1}. <span style="font-weight:600;">Item #${idx + 1}</span></div>`;
                        Object.entries(item).forEach(([k, v]) => {
                            if (typeof v === 'object' && v !== null) {
                                html += `<div>${indent}&nbsp;&nbsp;&nbsp;<span style="font-weight:600;">${titleCase(k)}:</span></div>`;
                                process(v, indentLevel + 1, k);
                            } else {
                                html += `<div>${indent}&nbsp;&nbsp;&nbsp;${titleCase(k)}: ${createValueSpan(k, v)}</div>`;
                            }
                        });
                    } else {
                        html += `<div>${indent}${idx + 1}. ${createValueSpan(pathPrefix, item)}</div>`;
                    }
                });
            } else if (typeof obj === 'object' && obj !== null) {
                Object.entries(obj).forEach(([k, v]) => {
                    const label = titleCase(k);
                    if (Array.isArray(v)) {
                        html += `<div style="margin-top: 1em; font-weight: 700;">${indent}${label}</div>`;
                        html += `<div>${indent}${"-".repeat(label.length)}</div>`;
                        process(v, indentLevel);
                    } else if (typeof v === 'object' && v !== null) {
                        html += `<div style="margin-top: 0.5em; font-weight: 600;">${indent}${label}</div>`;
                        process(v, indentLevel + 1);
                    } else {
                        if (k.toLowerCase().includes('note')) {
                            html += `<div>${indent}<strong>Note:</strong></div>`;
                            html += `<div>${indent}&nbsp;&nbsp;${createValueSpan(k, v)}</div>`;
                        } else {
                            html += `<div>${indent}${label}: ${createValueSpan(k, v)}</div>`;
                        }
                    }
                });
            }
        };

        if (Array.isArray(dataToSummarize.data)) {
            dataToSummarize.data.forEach((d, i) => {
                html += `<div style="margin-top: 1em; font-weight: 800;">RECORD #${i + 1}</div>`;
                html += `<div>================</div>`;
                process(d);
                html += `<br/>`;
            });
        } else {
            process(dataToSummarize.data);
        }

        html += `<div style="margin-top: 2em; opacity: 0.5;">------------------------------------</div>`;
        html += `<div>End of Report</div></div>`;
        return html;
    }, []);

    const triggerExplanation = useCallback(async (fieldName: string, fieldValue: string) => {
        setExplanationTarget({ fieldName, fieldValue });
        setIsExplanationLoading(true);
        setIsExplanationModalOpen(true);
        setActiveField(fieldName);
        try {
            const result = await getExplanationForField(fieldName, fieldValue, [file]);
            setExplanationContent(result);
        } catch {
            setExplanationContent("Could not retrieve field explanation.");
        } finally {
            setIsExplanationLoading(false);
        }
    }, [file]);

    const handleRegenerateSummary = useCallback(async () => {
        setIsSummaryLoading(true);
        try {
            const newSummary = await generateSummaryFromData(data, true);
            setSummary(newSummary);
        } catch (error) {
            setNotification({ message: "Failed to regenerate summary.", type: 'error' });
        } finally {
            setIsSummaryLoading(false);
        }
    }, [data]);

    const handleExplainSummary = useCallback(async () => {
        if (!summary) return;
        setExplanationTarget({ fieldName: "Intelligent Summary" });
        setIsExplanationLoading(true);
        setIsExplanationModalOpen(true);
        try {
            const result = await getExplanationForField("The entire document content", summary.summary, [file]);
            setExplanationContent(result);
        } catch {
            setExplanationContent("Failed to generate an explanation for the summary.");
        } finally {
            setIsExplanationLoading(false);
        }
    }, [summary, file]);

    useEffect(() => {
        setEditedData(data);
        setIsTextDirty(false); 
        setIsApproved(false);
        setApprovalStamp(null);
        if (settings.showSummary) {
            setIsSummaryLoading(true);
            generateSummaryFromData(data).then(setSummary).finally(() => setIsSummaryLoading(false));
        }
    }, [data, settings.showSummary]);

    const computedHtml = useMemo(() => {
        return generateTextSummary(editedData, activeField);
    }, [editedData, activeField, generateTextSummary]);

    useEffect(() => {
        if (!isTextDirty) {
            setTextContent(computedHtml);
        }
    }, [computedHtml, isTextDirty]);

    useEffect(() => {
        if (activeFormat === 'text' && editorRef.current) {
            const contentToRender = isTextDirty ? textContent : computedHtml;
            if (editorRef.current.innerHTML !== contentToRender) {
                editorRef.current.innerHTML = contentToRender;
            }
        }
    }, [activeFormat, isTextDirty, textContent, computedHtml]);

    useEffect(() => {
        const editor = editorRef.current;
        if (!editor) return;

        const handleEditorClick = (e: MouseEvent) => {
            const target = e.target as HTMLElement;
            const fieldName = target.getAttribute('data-field-name');
            if (fieldName) {
                const fieldValue = target.innerText;
                triggerExplanation(fieldName, fieldValue);
            }
        };

        editor.addEventListener('click', handleEditorClick);
        return () => {
            editor.removeEventListener('click', handleEditorClick);
        };
    }, [triggerExplanation, activeFormat]);

    const formattedDataForCopy = useMemo(() => {
        const meta = { source: "DataExtract AI", generatedAt: new Date().toISOString() };
        switch (activeFormat) {
            case 'json': 
            case 'key_value':
            case 'grid':
                return JSON.stringify({ 
                    _meta: meta, 
                    _approval: approvalStamp, 
                    data: editedData.data 
                }, null, 2);
            case 'text': 
                return formatAsOfficialDocument(editedData);
            default: 
                return JSON.stringify({ _meta: meta, data: editedData.data }, null, 2);
        }
    }, [activeFormat, editedData, approvalStamp]);

    const handleDownload = useCallback(async (format: string) => {
        if (settings.systemMode === 'ENTERPRISE' && !isApproved) {
            setNotification({ message: "Approval required before export in Enterprise Mode.", type: 'error' });
            return;
        }
        if (settings.systemMode === 'ENTERPRISE' && validationResult.issues.some(i => i.severity === 'error')) {
            setNotification({ message: "Resolve critical validation errors before exporting.", type: 'error' });
            return;
        }

        setIsDownloadOpen(false);
        setNotification({ message: `Exporting as ${format.toUpperCase()}...`, type: 'info' });
        
        logAuditEvent('EXPORT', settings.systemMode, { format, documentType: data.documentType });

        const baseFileName = file.file.name.split('.').slice(0, -1).join('.') || 'export';
        const fileName = `${baseFileName}.${format}`;

        const downloadBlob = (blob: Blob, name: string) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        const dataToExport = editedData.data;

        try {
            switch (format) {
                case 'json': {
                    const jsonOutput = {
                        _meta: { source: "DataExtract AI", generatedAt: new Date().toISOString() },
                        _approval: approvalStamp,
                        _auditLog: settings.systemMode === 'ENTERPRISE' ? getAuditLog() : undefined,
                        data: dataToExport
                    };
                    const jsonString = JSON.stringify(jsonOutput, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    downloadBlob(blob, fileName);
                    break;
                }
                case 'txt': {
                    const txtContent = formatAsOfficialDocument(editedData);
                    const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8;' });
                    downloadBlob(blob, fileName);
                    break;
                }
                case 'csv': {
                    const flattenedData = prepareDataForTable(Array.isArray(dataToExport) ? dataToExport : [dataToExport]);
                    const ws = XLSX.utils.json_to_sheet(flattenedData);
                    const csvOutput = XLSX.utils.sheet_to_csv(ws);
                    let finalCsv = `${csvOutput}\n\n${WATERMARK_TEXT}`;
                    if (approvalStamp) finalCsv += `\nApproved: ${approvalStamp.approvedAt}`;
                    const blob = new Blob([finalCsv], { type: 'text/csv;charset=utf-8;' });
                    downloadBlob(blob, fileName);
                    break;
                }
                case 'xlsx': {
                    const flattenedData = prepareDataForTable(Array.isArray(dataToExport) ? dataToExport : [dataToExport]);
                    const ws = XLSX.utils.json_to_sheet(flattenedData);
                    const range = XLSX.utils.decode_range(ws['!ref'] || "A1");
                    let watermarkRow = range.e.r + 2; 
                    XLSX.utils.sheet_add_aoa(ws, [[WATERMARK_TEXT]], { origin: { r: watermarkRow, c: 0 } });
                    if (approvalStamp) {
                        XLSX.utils.sheet_add_aoa(ws, [[`Approved: ${approvalStamp.approvedAt}`]], { origin: { r: watermarkRow + 1, c: 0 } });
                    }
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "Data");
                    XLSX.writeFile(wb, fileName);
                    break;
                }
                case 'pdf': {
                    const doc = new jsPDF();
                    doc.setFontSize(18);
                    doc.text(`Report: ${editedData.documentType}`, 14, 22);
                    doc.setFontSize(11);
                    doc.setTextColor(100);
                    doc.text(`Source: ${file.file.name}`, 14, 30);

                    const flattenedData = prepareDataForTable(Array.isArray(dataToExport) ? dataToExport : [dataToExport]);
                    if (flattenedData.length > 0) {
                        const headers = Object.keys(flattenedData[0]);
                        if (flattenedData.length === 1 && !Array.isArray(dataToExport)) {
                             const rows = Object.entries(flattenedData[0]);
                             autoTable(doc, { startY: 40, head: [['Field', 'Value']], body: rows });
                        } else {
                            autoTable(doc, { startY: 40, head: [headers], body: flattenedData.map((row: any) => Object.values(row)) });
                        }
                    }
                    
                    const pageCount = doc.getNumberOfPages();
                    doc.setFontSize(8);
                    doc.setTextColor(150);
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const footerText = approvalStamp ? `${WATERMARK_TEXT} | Approved: ${approvalStamp.approvedBy}` : WATERMARK_TEXT;

                    for (let i = 1; i <= pageCount; i++) {
                        doc.setPage(i);
                        doc.text(footerText, pageWidth - 10, pageHeight - 10, { align: 'right' });
                    }
                    doc.save(fileName);
                    break;
                }
                case 'png': {
                    const captureRef = resultsContentRef;
                    if (captureRef.current) {
                        const canvas = await html2canvas(captureRef.current, { backgroundColor: settings.darkMode ? '#1C1C1E' : '#F9FAFC' });
                        const dataUrl = canvas.toDataURL('image/png');
                        const a = document.createElement('a');
                        a.href = dataUrl;
                        a.download = fileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }
                    break;
                }
            }
            if (format !== 'xlsx') setNotification({ message: "File downloaded successfully!", type: 'success' });
        } catch (error) {
            const message = error instanceof Error ? error.message : "An unknown error occurred during export.";
            setNotification({ message: `Export failed: ${message}`, type: 'error' });
        }
    }, [editedData, file, settings.darkMode, approvalStamp, settings.systemMode, isApproved, validationResult.issues]);

    const exportTableToCSV = (table: DiscoveredTable) => {
        try {
            const flattenedData = prepareDataForTable(table.data);
            const ws = XLSX.utils.json_to_sheet(flattenedData);
            const csvOutput = XLSX.utils.sheet_to_csv(ws);
            let finalCsv = `${csvOutput}\n\n${WATERMARK_TEXT}`;
            if (approvalStamp) finalCsv += `\nApproved: ${approvalStamp.approvedAt}`;
            const blob = new Blob([finalCsv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${table.name.replace(/\s+/g, '_')}_export.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            setNotification({ message: `Downloaded ${table.name} as CSV`, type: 'success' });
        } catch (e) {
            setNotification({ message: "Failed to export table", type: 'error' });
        }
    };

    const renderData = (format: OutputFormat, dataToRender: any) => {
        switch (format) {
            case 'json': return <div className="p-6 h-full overflow-auto"><pre className="text-sm font-mono text-gray-800 dark:text-gray-300">{JSON.stringify(dataToRender, null, 2)}</pre></div>;
            case 'text': return (
                <div className="flex flex-col h-full bg-white dark:bg-zinc-900 relative">
                    <div 
                        ref={editorRef} 
                        contentEditable 
                        onInput={(e) => {
                            setTextContent(e.currentTarget.innerHTML);
                            setIsTextDirty(true);
                        }} 
                        className="flex-grow p-10 outline-none overflow-y-auto ios-scroll max-w-none min-h-[400px] text-gray-800 dark:text-gray-200 selection:bg-yellow-200/50 dark:selection:bg-yellow-900/30" 
                        style={{ fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace', fontSize: '0.9rem' }}
                    />
                </div>
            );
            case 'key_value':
                const rawObj = Array.isArray(dataToRender) ? dataToRender[0] : dataToRender;
                const kvData = flattenObject(rawObj || {});
                const entries = Object.entries(kvData);
                const filteredEntries = entries.filter(([key, value]) => {
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        if (!(key.toLowerCase().includes(q) || String(value).toLowerCase().includes(q))) return false;
                    }
                    if (showOnlyIssues) {
                        return validationResult.issues.some(issue => issue.involvedKeys.some(k => key.toLowerCase().includes(k.toLowerCase())));
                    }
                    return true;
                });
                if (filteredEntries.length === 0) return <div className="p-12 text-center text-gray-500 font-medium">No matching fields found.</div>;
                return (
                    <div className="p-6 space-y-4 h-full overflow-auto">
                        {!showOnlyIssues && validationResult.issues.length > 0 && (
                            <div className="mb-6 p-4 bg-red-50 dark:bg-red-500/10 border border-red-200 dark:border-red-500/20 rounded-xl space-y-2">
                                <div className="flex items-center gap-2 mb-2">
                                     <ShieldCheckIcon className="w-5 h-5 text-red-500" />
                                     <h4 className="font-bold text-red-800 dark:text-red-300">Logic & Consistency Checks</h4>
                                </div>
                                {validationResult.issues.map((issue, idx) => (
                                    <div key={idx} className="flex items-start gap-2 text-sm text-red-700 dark:text-red-400 ml-1">
                                        <span className={`mt-1.5 w-1.5 h-1.5 rounded-full flex-shrink-0 ${issue.severity === 'error' ? 'bg-red-500' : 'bg-orange-500'}`}></span>
                                        <span>{issue.message}</span>
                                    </div>
                                ))}
                            </div>
                        )}
                        {filteredEntries.map(([key, value]) => {
                             const rootKey = key.split(' > ')[0].toLowerCase();
                             const score = confidenceMap.get(rootKey) || confidenceMap.get(key); 
                             const isLowConfidence = score !== undefined && score < 90;
                             const isVeryLowConfidence = score !== undefined && score < 80;
                             const logicIssue = validationResult.issues.find(issue => issue.involvedKeys.some(k => key.toLowerCase().includes(k.toLowerCase())));
                             const isLogicIssue = !!logicIssue;
                             const issueColorClass = logicIssue?.severity === 'error' ? 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-900/30' : 'bg-orange-50 dark:bg-orange-900/10 border-orange-200 dark:border-orange-900/30';
                             const isListSummary = typeof value === 'string' && value.startsWith('[Table/List:');

                             return (
                                <div key={key} className={`flex items-center justify-between p-3 rounded-2xl border transition-all group ${activeField === key ? 'border-blue-500 ring-2 ring-blue-500/20' : 'border-black/5 dark:border-white/5'} ${isLogicIssue ? issueColorClass : (isLowConfidence ? 'bg-amber-50 dark:bg-amber-500/10' : 'bg-gray-50/50 dark:bg-zinc-800/50')}`}>
                                    <div className="flex items-center gap-2 overflow-hidden w-1/3">
                                        {isLogicIssue && <ExclamationTriangleIcon className={`w-4 h-4 flex-shrink-0 ${logicIssue?.severity === 'error' ? 'text-red-500' : 'text-orange-500'}`} />}
                                        {!isLogicIssue && isVeryLowConfidence && <Tooltip text="Low Confidence"><ExclamationTriangleIcon className="w-4 h-4 text-amber-500 flex-shrink-0" /></Tooltip>}
                                        <span className="text-sm font-bold uppercase tracking-wider truncate" title={key}>{key}</span>
                                        {settings.showConfidence && <ConfidenceBadge score={score} />}
                                    </div>
                                    <div className="text-sm font-medium ml-4 flex-1 flex items-center gap-2">
                                        <div className="flex-1">
                                            <EditableInput
                                                value={String(value)}
                                                onChange={(e) => handleKeyValueChange(key, e.target.value)}
                                                onBlur={(e) => handleInputBlur(key, e.target.value)}
                                                onFocus={() => { setActiveField(key); setShowSplitView(true); }}
                                                label={key}
                                                isActive={activeField === key}
                                                isEdited={editedFields.has(key)}
                                                disabled={isListSummary}
                                                className={isLogicIssue ? (logicIssue?.severity === 'error' ? 'text-red-900 dark:text-red-100' : 'text-orange-900 dark:text-orange-100') : (isLowConfidence ? 'text-amber-900 dark:text-amber-100' : '')}
                                            />
                                        </div>
                                        {isListSummary ? (
                                            <button onClick={() => setActiveFormat('grid')} className="p-1.5 text-gray-400 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg"><TableCellsIcon className="w-4 h-4" /></button>
                                        ) : (
                                            <button onClick={() => triggerExplanation(key, String(value))} className="p-1.5 text-gray-400 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg opacity-0 group-hover:opacity-100 focus:opacity-100"><LightBulbIcon className="w-4 h-4" /></button>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                );
            case 'grid':
                if (tables.length === 0) return <div className="flex flex-col items-center justify-center h-full text-gray-500"><TableCellsIcon className="w-12 h-12 mb-3 opacity-20" /><p>No table structures detected.</p></div>;
                const currentTable = tables[activeTableIndex] || tables[0];
                if (!currentTable || !currentTable.data || currentTable.data.length === 0) return <div className="p-6 text-center text-gray-500">Empty table data.</div>;
                const keys = Object.keys(currentTable.data[0]);
                const filteredRows = currentTable.data.filter((row, i) => {
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        if (!Object.values(row).some(v => String(v).toLowerCase().includes(q))) return false;
                    }
                    if (showOnlyIssues) {
                        return keys.some(k => validationResult.issues.some(issue => (issue.rowIndex === undefined || issue.rowIndex === i) && issue.involvedKeys.some(ik => k.toLowerCase().includes(ik.toLowerCase()))));
                    }
                    return true;
                });
                if (filteredRows.length === 0) return <div className="p-12 text-center text-gray-500 font-medium">No matching rows found.</div>;
                return (
                    <div className="flex flex-col h-full overflow-hidden">
                        <div className="flex-shrink-0 flex items-center justify-between px-6 py-3 border-b border-black/5 dark:border-white/5 bg-gray-50/50 dark:bg-zinc-800/50">
                            <div className="flex space-x-1 overflow-x-auto ios-scroll no-scrollbar">
                                {tables.length > 1 ? tables.map((t, i) => (
                                    <button key={i} onClick={() => setActiveTableIndex(i)} className={`px-3 py-1.5 text-xs font-bold rounded-lg transition-all whitespace-nowrap ${activeTableIndex === i ? 'bg-white dark:bg-zinc-700 text-[#007AFF] shadow-sm' : 'text-gray-500 hover:bg-black/5'}`}>{t.name}</button>
                                )) : <span className="text-xs font-bold text-gray-500 uppercase tracking-widest">{currentTable.name}</span>}
                            </div>
                            <button onClick={() => exportTableToCSV(currentTable)} className="p-1.5 text-gray-500 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg"><ArrowDownTrayIcon className="w-4 h-4" /></button>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table ref={tableRef} className="w-full text-left border-collapse min-w-[600px]">
                                <thead className="sticky top-0 bg-white dark:bg-zinc-900 z-10 shadow-sm">
                                    <tr className="border-b border-black/5 dark:border-white/5">{keys.map(k => <th key={k} className="p-4 text-xs font-bold uppercase tracking-widest text-gray-500 dark:text-gray-400 bg-gray-50/80 dark:bg-zinc-800/80 backdrop-blur-sm">{k}</th>)}</tr>
                                </thead>
                                <tbody>
                                    {filteredRows.map((row: any, i: number) => (
                                        <tr key={i} className="border-b border-black/5 dark:border-white/5 hover:bg-gray-50/50 dark:hover:bg-white/5">
                                            {keys.map(k => {
                                                const score = confidenceMap.get(k);
                                                const isLow = score !== undefined && score < 90;
                                                const issue = validationResult.issues.find(issue => (issue.rowIndex === undefined || issue.rowIndex === i) && issue.involvedKeys.some(ik => k.toLowerCase().includes(ik.toLowerCase())));
                                                const hasIssue = !!issue;
                                                const issueStyle = issue?.severity === 'error' ? 'bg-red-50 dark:bg-red-900/20 ring-1 ring-red-500/50 inset-0' : 'bg-orange-50 dark:bg-orange-900/20 ring-1 ring-orange-500/50 inset-0';
                                                return (
                                                    <td key={k} className={`p-2 text-sm relative ${hasIssue ? issueStyle : ''} ${!hasIssue && isLow ? 'bg-amber-50/30 dark:bg-amber-500/5' : ''}`}>
                                                        <div className="flex items-center gap-1 group/cell">
                                                            {hasIssue && <Tooltip text={issue?.message}><ExclamationTriangleIcon className={`w-3.5 h-3.5 flex-shrink-0 ${issue?.severity === 'error' ? 'text-red-500' : 'text-orange-500'}`} /></Tooltip>}
                                                            <div className="flex-1 min-w-0">
                                                                <EditableInput value={String(row[k] ?? '')} onChange={(e) => handleGridChange(i, k, e.target.value)} onBlur={(e) => handleInputBlur(k, e.target.value, i)} onFocus={() => { setActiveField(k); setShowSplitView(true); }} label={k} isActive={activeField === k} isEdited={editedFields.has(`${currentTable.path || 'root'}-${i}-${k}`)} />
                                                            </div>
                                                            <button onClick={() => triggerExplanation(k, String(row[k] ?? ''))} className="p-1 text-gray-400 hover:text-[#007AFF] rounded-md opacity-0 group-hover/cell:opacity-100 focus:opacity-100 flex-shrink-0"><LightBulbIcon className="w-3.5 h-3.5" /></button>
                                                        </div>
                                                    </td>
                                                );
                                            })}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            default: return null;
        }
    };

    const isSearchable = activeFormat === 'key_value' || activeFormat === 'grid';

    return (
        <div className="flex flex-col h-full w-full">
            {notification && <Notification message={notification.message} type={notification.type} onClose={() => setNotification(null)} />}
            <ExplanationModal isOpen={isExplanationModalOpen} onClose={() => setIsExplanationModalOpen(false)} target={explanationTarget} explanation={explanationContent} isLoading={isExplanationLoading} />
            <SaveTemplateModal isOpen={isTemplateModalOpen} onClose={() => setIsTemplateModalOpen(false)} onSave={() => {}} />

            {/* Pane Header Group */}
            <div className="flex-shrink-0 bg-white/80 dark:bg-zinc-900/80 backdrop-blur-xl z-10 transition-colors duration-300 border-b border-black/5 dark:border-white/5">
                <div className="flex justify-between items-center p-4 pb-2">
                    <div>
                        <h2 className="text-xl font-extrabold tracking-tight text-[#1d1d1f] dark:text-white">Results</h2>
                        <p className="text-xs font-bold text-[#5856D6] dark:text-[#AF52DE] uppercase tracking-widest">{data.documentType}</p>
                    </div>
                    <div className="flex items-center gap-3">
                         {isSearchable && validationResult.issues.length > 0 && (
                            <button onClick={() => setShowOnlyIssues(!showOnlyIssues)} className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-bold transition-all border ${showOnlyIssues ? 'bg-red-50 text-red-700 dark:bg-red-900/30 dark:text-red-300 border-red-200 dark:border-red-800' : 'bg-black/5 dark:bg-white/5 text-gray-500 dark:text-gray-400 hover:bg-black/10 border-transparent'}`}>
                                <ShieldCheckIcon className={`w-3.5 h-3.5 ${showOnlyIssues ? 'text-red-500' : ''}`} />
                                <span>{showOnlyIssues ? 'Showing Issues' : `${validationResult.issues.length} Issues`}</span>
                            </button>
                        )}
                         {isSearchable && (
                            <div className="relative group/search">
                                <MagnifyingGlassIcon className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400 group-focus-within/search:text-blue-500 transition-colors" />
                                <input type="text" placeholder="Search fields..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="pl-9 pr-8 py-1.5 text-sm bg-gray-100 dark:bg-zinc-800 border-transparent focus:bg-white dark:focus:bg-black border focus:border-blue-500 rounded-lg outline-none transition-all w-48 focus:w-64 text-gray-800 dark:text-gray-200 placeholder-gray-500" />
                                {searchQuery && <button onClick={() => setSearchQuery('')} className="absolute right-2 top-1/2 -translate-y-1/2 p-0.5 rounded-full text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 hover:bg-black/5 dark:hover:bg-white/10"><XMarkIcon className="w-3.5 h-3.5" /></button>}
                            </div>
                        )}
                        {file.file.type.startsWith('image/') && (
                             <Tooltip text={showSplitView ? "Close Split View" : "Review with Split View"}>
                                <button onClick={() => setShowSplitView(p => !p)} className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-bold transition-all ${showSplitView ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/30' : 'bg-black/5 dark:bg-white/5 text-gray-500 dark:text-gray-400 hover:bg-black/10'}`}>
                                    <ViewColumnsIcon className="w-4 h-4" />
                                    <span className="hidden sm:inline">Split View</span>
                                </button>
                            </Tooltip>
                        )}
                    </div>
                </div>
                
                {/* Segmented Control Tabs */}
                <div className="px-4 pb-4">
                    <div className="flex p-1 bg-gray-100/80 dark:bg-zinc-800/80 backdrop-blur-md rounded-xl border border-black/5 dark:border-white/5">
                        {outputFormats.map(f => (
                             <button 
                                key={f.id} 
                                onClick={() => setActiveFormat(f.id)} 
                                className={`flex-1 py-2 text-xs font-bold rounded-lg transition-all duration-300 ${activeFormat === f.id ? 'bg-white dark:bg-zinc-700 text-[#007AFF] dark:text-[#0A84FF] shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'}`}
                            >
                                {f.label}
                            </button>
                        ))}
                    </div>
                </div>
            </div>

            <div className="flex-grow flex overflow-hidden">
                <div className={`flex-1 flex flex-col overflow-hidden transition-all duration-300 ${showSplitView ? 'w-1/2 border-r border-black/5 dark:border-white/5' : 'w-full'}`}>
                    <div ref={resultsContentRef} className="flex-grow overflow-y-auto ios-scroll p-6 space-y-8 bg-transparent">
                        {settings.showSummary && <div className="animate-summary"><AISummary summary={summary} loading={isSummaryLoading} onRegenerate={handleRegenerateSummary} onExplain={handleExplainSummary} /></div>}
                        
                        {/* Tab Content with Fade Transition */}
                        <div className="border border-black/5 dark:border-white/5 rounded-2xl overflow-hidden min-h-[400px] bg-white/40 dark:bg-zinc-800/40 backdrop-blur-sm">
                           <div key={activeFormat} className="h-full w-full animate-fade-in">
                                {renderData(activeFormat, editedData.data)}
                           </div>
                        </div>

                        <div className="mt-8 pt-4 pb-2 border-t border-dashed border-gray-200 dark:border-zinc-700 flex justify-end opacity-60 hover:opacity-100 transition-opacity select-none">
                            <span className="text-[10px] font-mono text-gray-400 dark:text-zinc-500 uppercase tracking-widest">
                                {WATERMARK_TEXT} {approvalStamp && `| Approved by: ${approvalStamp.approvedBy}`}
                            </span>
                        </div>
                        <div className="h-24" />
                    </div>
                </div>
                {showSplitView && (
                    <div className="w-1/2 bg-gray-50/50 dark:bg-black/20 flex flex-col overflow-hidden animate-fade-in backdrop-blur-sm">
                        <div className="flex items-center justify-between p-3 border-b border-black/5 dark:border-white/5 bg-white/50 dark:bg-zinc-800/50 backdrop-blur-md">
                            <span className="text-xs font-bold uppercase tracking-wider text-gray-500">Source Document</span>
                            <span className="text-[10px] text-gray-400">Click a field on left to zoom</span>
                        </div>
                        <div className="flex-grow relative overflow-hidden">
                            <DocumentHighlighter file={file} highlights={data.highlights || []} hoveredField={null} activeField={activeField} onHoverField={() => {}} showHighlights={true} />
                        </div>
                    </div>
                )}
            </div>
            
            {!showSplitView && (
                <div className="absolute bottom-0 left-0 right-0 z-10 bg-gradient-to-t from-white via-white/95 to-transparent dark:from-zinc-900 dark:via-zinc-900/95 pt-12 pb-4 px-4 pointer-events-none">
                    <div className="flex flex-col sm:flex-row items-stretch sm:items-center justify-center gap-3 w-full max-w-2xl mx-auto p-2 bg-white/60 dark:bg-zinc-800/60 backdrop-blur-2xl rounded-[2.5rem] border border-white/20 dark:border-white/5 shadow-2xl transition-all pointer-events-auto">
                        {!isApproved ? (
                            <Tooltip text="Lock in corrections & finalize" position="top">
                                <button onClick={handleApprove} className="w-full flex items-center justify-center gap-2.5 py-4 px-8 bg-[#34C759] text-white font-bold rounded-[2rem] hover:shadow-glow-blue-strong active:scale-95 transition-all shadow-lg whitespace-nowrap">
                                    <CheckCircleIcon className="w-5 h-5" /> Approve & Finalize
                                </button>
                            </Tooltip>
                        ) : (
                            <div className="flex flex-wrap sm:flex-nowrap items-center justify-center gap-3 w-full">
                                <Tooltip text="Copy output to clipboard" position="top">
                                    <button onClick={() => { navigator.clipboard.writeText(formattedDataForCopy); setCopied(true); setTimeout(() => setCopied(false), 2000); }} className="w-full sm:flex-1 min-w-[140px] flex items-center justify-center gap-2.5 py-3.5 px-6 bg-black/5 dark:bg-white/5 text-gray-900 dark:text-gray-100 font-bold rounded-[2rem] hover:bg-black/10 transition-all">
                                        <ClipboardDocumentIcon className="w-5 h-5"/> {copied ? 'Copied' : 'Copy'}
                                    </button>
                                </Tooltip>
                                
                                <div ref={downloadMenuRef} className="relative w-full sm:flex-1 min-w-[140px]">
                                    <Tooltip text="Save as local file" position="top">
                                        <button onClick={() => setIsDownloadOpen(p => !p)} className={`w-full flex items-center justify-center gap-2.5 py-3.5 px-6 font-bold rounded-[2rem] transition-all border ${isDownloadOpen ? 'bg-white text-[#007AFF] border-[#007AFF] shadow-glow-blue-strong' : 'bg-[#007AFF] text-white border-transparent hover:shadow-glow-blue-strong active:scale-95'}`}>
                                            <ArrowDownTrayIcon className="w-5 h-5"/> Download
                                            <ChevronDownIcon className={`w-4 h-4 transition-transform duration-300 ${isDownloadOpen ? 'rotate-180' : ''}`} />
                                        </button>
                                    </Tooltip>
                                    
                                    <div className={`absolute bottom-full mb-4 left-1/2 -translate-x-1/2 w-80 bg-white/90 dark:bg-zinc-900/90 backdrop-blur-2xl rounded-3xl shadow-[0_20px_40px_-10px_rgba(0,0,0,0.2)] border border-white/20 dark:border-white/10 p-2 z-50 transition-all duration-300 ease-out origin-bottom ${isDownloadOpen ? 'opacity-100 translate-y-0 scale-100' : 'opacity-0 translate-y-4 scale-95 pointer-events-none'}`}>
                                        <div className="px-4 py-3 border-b border-black/5 dark:border-white/5 mb-1">
                                            <h3 className="text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-widest">Select Format</h3>
                                        </div>
                                        <div className="space-y-1 p-1 max-h-[300px] overflow-y-auto ios-scroll">
                                            {downloadOptions.map(({ format, label, description, icon: Icon }) => (
                                                <button key={format} onClick={() => handleDownload(format)} className="w-full flex items-center gap-4 text-left p-3 hover:bg-blue-50 dark:hover:bg-white/5 rounded-2xl transition-all group/item border border-transparent hover:border-blue-500/10">
                                                    <div className="w-10 h-10 rounded-full bg-blue-500/10 dark:bg-blue-500/20 flex items-center justify-center text-blue-600 dark:text-blue-400 group-hover/item:bg-blue-500 group-hover/item:text-white transition-colors">
                                                        <Icon className="w-5 h-5" />
                                                    </div>
                                                    <div>
                                                        <p className="font-bold text-sm text-gray-800 dark:text-gray-100">{label}</p>
                                                        <p className="text-[11px] font-medium text-gray-500 dark:text-gray-400">{description}</p>
                                                    </div>
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            )}
        </div>
    );
};
