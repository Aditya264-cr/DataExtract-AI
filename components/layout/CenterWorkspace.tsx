
import React, { useState, useCallback, useMemo, useEffect, useRef, useContext } from 'react';
import type { ExtractedData, OutputFormat, UploadedFile, AISummaryData } from '../../types';
import { generateSummaryFromData, getExplanationForField } from '../../services/geminiService';
import { autoFormatValue, validateDocumentLogic } from '../../utils/validationUtils';
import { SettingsContext } from '../../contexts/SettingsContext';
import { useClickOutside } from '../../hooks/useClickOutside';
import { AISummary } from '../AISummary';
import { SaveTemplateModal } from '../ui/SaveTemplateModal';
import { TableCellsIcon } from '../icons/TableCellsIcon';
import { PhotoIcon } from '../icons/PhotoIcon';
import { ViewColumnsIcon } from '../icons/ViewColumnsIcon';
import { ExclamationTriangleIcon } from '../icons/ExclamationTriangleIcon';
import { DocumentHighlighter } from '../DocumentHighlighter';
import { ShieldCheckIcon } from '../icons/ShieldCheckIcon';
import { flattenObject, extractTables, updateNestedState, updateTableData, DiscoveredTable } from '../../utils/dataAdapter';
import { formatAsOfficialDocument } from '../../utils/textFormatter';
import { MagnifyingGlassIcon } from '../icons/MagnifyingGlassIcon';
import { XMarkIcon } from '../icons/XMarkIcon';
import { Notification } from '../ui/Notification';
import { logAuditEvent } from '../../utils/auditLogger';
import { LightBulbIcon } from '../icons/LightBulbIcon';
import { ExplanationModal } from '../ui/ExplanationModal';
import { Tooltip } from '../ui/Tooltip';
import { CalendarIcon } from '../icons/CalendarIcon';
import { MapPinIcon } from '../icons/MapPinIcon';
import { EnvelopeIcon } from '../icons/EnvelopeIcon';
import { PhoneIcon } from '../icons/PhoneIcon';
import { ArrowDownTrayIcon } from '../icons/ArrowDownTrayIcon';
import { AlignLeftIcon } from '../icons/AlignLeftIcon';
import { AlignCenterIcon } from '../icons/AlignCenterIcon';
import { AlignRightIcon } from '../icons/AlignRightIcon';
import { ClearFormattingIcon } from '../icons/ClearFormattingIcon';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

interface CenterWorkspaceProps {
    initialData: ExtractedData;
    editedData: ExtractedData;
    onDataChange: (newData: ExtractedData) => void;
    file: UploadedFile;
    onNewUpload: () => void;
    onReprocess: (editedData: ExtractedData) => void;
}

const WATERMARK_TEXT = "Generated by DataExtract AI";

const outputFormats: { id: OutputFormat; label: string; tooltip: string }[] = [
    { id: 'key_value', label: 'Key-Value', tooltip: 'Flat data mapping' },
    { id: 'grid', label: 'Grid', tooltip: 'Tabular spreadsheet view' },
    { id: 'text', label: 'Report', tooltip: 'Official document text' },
    { id: 'json', label: 'JSON', tooltip: 'Raw technical structure' },
];

const ConfidenceBadge: React.FC<{ score: number | undefined }> = ({ score }) => {
    if (score === undefined) return null;
    let colorClass = 'bg-[#FF3B30] text-white'; 
    if (score >= 85) colorClass = 'bg-[#34C759] text-white';
    else if (score >= 60) colorClass = 'bg-[#FF9500] text-white'; 

    return (
        <span className={`inline-flex items-center px-1.5 py-0.5 rounded text-[10px] font-bold ${colorClass} ml-2 flex-shrink-0 animate-fade-in shadow-sm`}>
            {score}%
        </span>
    );
};

const EditableInput = ({ 
    value, onChange, onBlur, label, onFocus, isActive, isEdited, className, disabled 
}: { 
    value: string; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void; label: string; onFocus?: () => void; isActive?: boolean; isEdited?: boolean; className?: string; disabled?: boolean;
}) => (
    <input
        type="text"
        value={value}
        onChange={onChange}
        onFocus={onFocus}
        onBlur={onBlur}
        aria-label={label}
        disabled={disabled}
        className={`w-full bg-transparent p-1.5 -ml-1.5 border-none rounded-md transition-all text-sm font-medium ${isActive ? 'bg-blue-50 dark:bg-blue-900/30 ring-1 ring-blue-200 dark:ring-blue-800' : 'hover:bg-gray-100 dark:hover:bg-zinc-800'} ${isEdited ? 'bg-amber-50 dark:bg-amber-900/20' : ''} ${disabled ? 'opacity-60 cursor-not-allowed italic' : ''} ${className || ''} focus:ring-2 focus:ring-blue-500 focus:bg-white dark:focus:bg-black outline-none`}
    />
);

const getConfidenceColor = (score: number | undefined) => {
    if (score === undefined) return 'text-gray-900 dark:text-gray-100';
    if (score >= 85) return 'text-green-700 dark:text-green-400';
    if (score >= 60) return 'text-orange-700 dark:text-orange-400';
    return 'text-red-700 dark:text-red-400';
};

export const CenterWorkspace: React.FC<CenterWorkspaceProps> = ({ initialData, editedData, onDataChange, file, onNewUpload, onReprocess }) => {
    const { settings } = useContext(SettingsContext);
    const [activeFormat, setActiveFormat] = useState<OutputFormat>('key_value');
    const [editedFields, setEditedFields] = useState(new Set<string>());
    const [isTemplateModalOpen, setIsTemplateModalOpen] = useState(false);
    const [textContent, setTextContent] = useState('');
    const [isTextDirty, setIsTextDirty] = useState(false);
    const [summary, setSummary] = useState<AISummaryData | null>(null);
    const [isSummaryLoading, setIsSummaryLoading] = useState<boolean>(true);
    const [activeField, setActiveField] = useState<string | null>(null);
    const [notification, setNotification] = useState<{ message: string; type: 'success' | 'error' | 'info'; action?: any } | null>(null);
    const [isExplanationModalOpen, setIsExplanationModalOpen] = useState(false);
    const [explanationTarget, setExplanationTarget] = useState<{ fieldName: string; fieldValue?: string } | null>(null);
    const [explanationContent, setExplanationContent] = useState<string | null>(null);
    const [isExplanationLoading, setIsExplanationLoading] = useState(false);
    const [showSplitView, setShowSplitView] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [showOnlyIssues, setShowOnlyIssues] = useState(false);
    const [isExportingPDF, setIsExportingPDF] = useState(false);
    
    // Rich Text State
    const [textAlign, setTextAlign] = useState<'left' | 'center' | 'right'>('left');
    
    // Table Discovery State using Adapter
    const [activeTableIndex, setActiveTableIndex] = useState(0);
    const tables = useMemo(() => extractTables(editedData), [editedData]);

    const tableRef = useRef<HTMLTableElement>(null);
    const editorRef = useRef<HTMLDivElement>(null);
    const resultsContentRef = useRef<HTMLDivElement>(null);

    // Validation Results
    // 1. Flattened validation for Key-Value view
    const validationResult = useMemo(() => validateDocumentLogic(flattenObject(editedData)), [editedData]);
    
    // 2. Table-specific validation for Grid view (enables row highlighting)
    const currentTable = tables[activeTableIndex];
    const gridValidationResult = useMemo(() => {
        if (activeFormat === 'grid' && currentTable?.data) {
            return validateDocumentLogic(currentTable.data);
        }
        return { isValid: true, issues: [] };
    }, [activeFormat, currentTable]);
    
    // Reset table index if data structure changes significantly
    useEffect(() => {
        if (activeTableIndex >= tables.length && tables.length > 0) {
            setActiveTableIndex(0);
        }
    }, [tables.length, activeTableIndex]);
    
    useEffect(() => {
        setSearchQuery('');
        setShowOnlyIssues(false);
    }, [activeFormat]);

    // Rich Text Editor Helpers
    const updateToolbarState = useCallback(() => {
        if (document.queryCommandState('justifyCenter')) setTextAlign('center');
        else if (document.queryCommandState('justifyRight')) setTextAlign('right');
        else setTextAlign('left');
    }, []);

    const handleFormat = (command: string) => {
        document.execCommand(command, false);
        if (editorRef.current) {
            editorRef.current.focus();
            updateToolbarState();
            // Mark as dirty so changes persist over auto-generation
            setIsTextDirty(true);
            setTextContent(editorRef.current.innerHTML);
        }
    };

    // Keep toolbar state in sync with selection
    useEffect(() => {
        if (activeFormat !== 'text') return;
        const handleSelectionChange = () => {
            // Only update if selection is inside editor
            if (editorRef.current && (document.activeElement === editorRef.current || editorRef.current.contains(document.activeElement))) {
                updateToolbarState();
            }
        };
        document.addEventListener('selectionchange', handleSelectionChange);
        return () => document.removeEventListener('selectionchange', handleSelectionChange);
    }, [activeFormat, updateToolbarState]);

    const confidenceMap = useMemo(() => {
        const map = new Map<string, number>();
        initialData.highlights?.forEach(h => { map.set(h.fieldName, h.confidence); });
        return map;
    }, [initialData.highlights]);

    const handleKeyValueChange = (flattenedKey: string, value: string) => {
        onDataChange(updateNestedState(editedData, flattenedKey, value));
        setEditedFields(prev => new Set(prev).add(flattenedKey));
        
        logAuditEvent('EDIT', settings.systemMode, {
            documentId: editedData.documentType,
            fieldsEdited: [flattenedKey],
            newValue: value
        });
    };

    const handleGridChange = (rowIndex: number, key: string, value: string) => {
        const currentTable = tables[activeTableIndex];
        if (!currentTable) return;

        onDataChange(updateTableData(editedData, currentTable.path, rowIndex, key, value));
        const cellKey = `${currentTable.path || 'root'}-${rowIndex}-${key}`;
        setEditedFields(prev => new Set(prev).add(cellKey));

        logAuditEvent('EDIT', settings.systemMode, {
            documentId: editedData.documentType,
            fieldsEdited: [cellKey],
            newValue: value
        });
    };

    const handleInputBlur = (key: string, value: string, rowIndex?: number) => {
        const formatted = autoFormatValue(key, value);
        if (formatted !== value) {
            if (rowIndex !== undefined) {
                handleGridChange(rowIndex, key, formatted);
            } else {
                handleKeyValueChange(key, formatted);
            }
            setNotification({ message: 'Auto-formatted value for consistency', type: 'info' });
        }
    };

    // --- Action Button Logic ---
    const getActionForValue = (key: string, value: string) => {
        if (!value || typeof value !== 'string') return null;
        const lowerKey = key.toLowerCase();
        
        // 1. Email
        if (lowerKey.includes('email') || /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
             if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
                return { type: 'email', icon: EnvelopeIcon, label: "Send Email", action: () => window.open(`mailto:${value}`) };
             }
        }
        // 2. Phone
        if ((lowerKey.includes('phone') || lowerKey.includes('mobile') || lowerKey.includes('fax') || lowerKey.includes('contact') || lowerKey.includes('tel') || lowerKey.includes('cell')) && value.length > 5 && /[0-9]/.test(value)) {
            return { type: 'phone', icon: PhoneIcon, label: "Call", action: () => window.open(`tel:${value.replace(/[^\d+]/g, '')}`) };
        }
        // 3. Date -> Google Calendar
        if ((lowerKey.includes('date') || lowerKey.includes('due') || lowerKey.includes('expires') || lowerKey.includes('schedule') || lowerKey.includes('dob') || lowerKey.includes('birth') || lowerKey.includes('deadline')) && !isNaN(Date.parse(value)) && /\d/.test(value)) {
            return {
                type: 'calendar',
                icon: CalendarIcon, label: "Add to Calendar",
                action: () => {
                    const date = new Date(value);
                    if (isNaN(date.getTime())) return;
                    const iso = date.toISOString().replace(/-|:|\.\d+/g, '');
                    const dateStr = iso.slice(0, 8);
                    const datesParam = `${dateStr}/${dateStr}`;
                    const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(key)}&dates=${datesParam}&details=${encodeURIComponent('Value: ' + value + '\nSource: ' + editedData.documentType)}`;
                    window.open(url, '_blank');
                }
            };
        }
        // 4. Address -> Google Maps
        if ((lowerKey.includes('address') || lowerKey.includes('location') || lowerKey.includes('city') || lowerKey.includes('street') || lowerKey.includes('venue') || lowerKey.includes('residence') || lowerKey.includes('office') || lowerKey.includes('hq') || lowerKey.includes('destination')) && value.length > 5) {
            if (!value.includes('http') && !/^[0-9]+$/.test(value)) {
                return { type: 'map', icon: MapPinIcon, label: "Open Maps", action: () => window.open(`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(value.replace(/\n/g, ', '))}`, '_blank') };
            }
        }
        return null;
    };

    const generateTextSummary = useCallback((dataToSummarize: ExtractedData, currentActiveField: string | null): string => {
        // We use the new formatter logic but wrap it in HTML structures for display
        const reportText = formatAsOfficialDocument(dataToSummarize, settings.showWatermark);
        
        // Escape HTML basics first
        let html = reportText.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        
        // --- TEXT VIEW INTERACTIVITY ---
        // We inject interactivity into standard field lines "   • Label: Value"
        // This allows the "Text View" to also have "Explain This" functionality and Smart Actions
        // Regex matches lines starting with "   • "
        html = html.replace(/^([ \t]*•\s+)([^:]+)(:\s+)(.+)$/gm, (match, prefix, label, separator, value) => {
            const fieldName = label.trim();
            const valClean = value.trim();
            const actionItem = getActionForValue(fieldName, valClean);
            
            // Generate HTML for Action Icon (if applicable)
            let actionHtml = '';
            if (actionItem) {
                // Inline SVG definitions for text view helpers
                let svgPath = '';
                if (actionItem.type === 'email') svgPath = 'M21.75 6.75v10.5a2.25 2.25 0 0 1-2.25 2.25h-15a2.25 2.25 0 0 1-2.25-2.25V6.75m19.5 0A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25m19.5 0v.243a2.25 2.25 0 0 1-1.07 1.916l-7.5 4.615a2.25 2.25 0 0 1-2.36 0L3.32 8.91a2.25 2.25 0 0 1-1.07-1.916V6.75';
                else if (actionItem.type === 'phone') svgPath = 'M2.25 6.75c0 8.284 6.716 15 15 15h2.25a2.25 2.25 0 0 0 2.25-2.25v-1.372c0-.516-.351-.966-.852-1.091l-4.423-1.106c-.44-.11-.902.055-1.173.417l-.97 1.293c-.282.376-.769.542-1.21.38a12.035 12.035 0 0 1-7.143-7.143c-.162-.441.004-.928.38-1.21l1.293-.97c.363-.271.527-.734.417-1.173L6.963 3.102a1.125 1.125 0 0 0-1.091-.852H4.5A2.25 2.25 0 0 0 2.25 4.5v2.25Z';
                else if (actionItem.type === 'calendar') svgPath = 'M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0v-7.5A2.25 2.25 0 0 1 5.25 9h13.5A2.25 2.25 0 0 1 21 11.25v7.5m-9-6h.008v.008H12v-.008ZM12 15h.008v.008H12V15Zm0 2.25h.008v.008H12v-.008ZM9.75 15h.008v.008H9.75V15Zm0 2.25h.008v.008H9.75v-.008ZM7.5 15h.008v.008H7.5V15Zm0 2.25h.008v.008H7.5v-.008Zm6.75-4.5h.008v.008h-.008v-.008Zm0 2.25h.008v.008h-.008V15Zm0 2.25h.008v.008h-.008v-.008Zm2.25-4.5h.008v.008H16.5v-.008Zm0 2.25h.008v.008H16.5V15Z';
                else if (actionItem.type === 'map') svgPath = 'M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z';

                actionHtml = `<span class="inline-flex items-center justify-center cursor-pointer text-blue-500 hover:text-blue-700 bg-blue-50 hover:bg-blue-100 rounded-md p-0.5 ml-2 transition-colors relative z-10" title="${actionItem.label}" data-action-type="${actionItem.type}" data-action-value="${valClean}" data-action-key="${fieldName}"><svg class="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="${svgPath}" /></svg></span>`;
            }

            // We wrap the whole line content in a span that triggers the explain click handler
            // Explain icon appears on hover
            const explainIcon = `<span class="inline-flex items-center justify-center opacity-0 group-hover/line:opacity-100 transition-opacity absolute right-0 top-1/2 -translate-y-1/2 translate-x-full pl-2 pointer-events-none"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 text-amber-500 bg-amber-50 rounded-full p-0.5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m-6.375-3.375a3 3 0 0 1 3-3h1.5a3 3 0 0 1 3 3v.375M17.25 12A5.25 5.25 0 0 1 12 17.25 5.25 5.25 0 0 1 6.75 12A5.25 5.25 0 0 1 12 6.75a5.25 5.25 0 0 1 5.25 5.25Z" /></svg></span>`;
            
            return `${prefix}<span class="group/line relative cursor-help border-b border-dotted border-transparent hover:border-gray-300 dark:hover:border-gray-600 transition-colors" data-field-name="${fieldName}">${label}${separator}${value}${actionHtml}${explainIcon}</span>`;
        });

        // Wrap the whole thing in a styled container
        return `<div style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; line-height: 1.6; color: inherit; white-space: pre-wrap;">${html}</div>`;
    }, [settings.showWatermark]);

    const triggerExplanation = useCallback(async (fieldName: string, fieldValue: string) => {
        setExplanationTarget({ fieldName, fieldValue });
        setIsExplanationLoading(true);
        setIsExplanationModalOpen(true);
        setActiveField(fieldName);
        try {
            const result = await getExplanationForField(fieldName, fieldValue, [file]);
            setExplanationContent(result);
        } catch {
            setExplanationContent("Could not retrieve field explanation.");
        } finally {
            setIsExplanationLoading(false);
        }
    }, [file]);

    const handleRegenerateSummary = useCallback(async () => {
        setIsSummaryLoading(true);
        try {
            const newSummary = await generateSummaryFromData(editedData, true);
            setSummary(newSummary);
        } catch (error) {
            setNotification({ message: "Failed to regenerate summary.", type: 'error' });
        } finally {
            setIsSummaryLoading(false);
        }
    }, [editedData]);

    const handleExplainSummary = useCallback(async () => {
        if (!summary) return;
        setExplanationTarget({ fieldName: "Intelligent Summary" });
        setIsExplanationLoading(true);
        setIsExplanationModalOpen(true);
        try {
            const result = await getExplanationForField("The entire document content", summary.summary, [file]);
            setExplanationContent(result);
        } catch {
            setExplanationContent("Failed to generate an explanation for the summary.");
        } finally {
            setIsExplanationLoading(false);
        }
    }, [summary, file]);

    const exportTableToCSV = (table: DiscoveredTable) => {
        if (!table.data || table.data.length === 0) return;
        const headers = Object.keys(table.data[0]);
        const rows = table.data.map(row => headers.map(header => {
            const cell = row[header];
            const val = cell && typeof cell === 'object' && 'value' in cell ? cell.value : cell;
            const str = String(val ?? '').replace(/"/g, '""');
            return `"${str}"`;
        }).join(','));
        const csvContent = [headers.join(','), ...rows].join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `${table.name || 'table'}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    const handleExportPDF = async () => {
        if (isExportingPDF) return;
        setIsExportingPDF(true);
        try {
            const fileName = `export_${editedData.documentType.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${Date.now()}.pdf`;
            const doc = new jsPDF();
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            
            // Header
            doc.setFontSize(18);
            doc.text(editedData.documentType, 14, 20);
            
            doc.setFontSize(10);
            doc.setTextColor(100);
            doc.text(`Confidence: ${editedData.confidenceScore}%  |  Date: ${new Date().toLocaleDateString()}`, 14, 26);
            doc.setTextColor(0);

            let currentY = 35;

            // Summary if available - Use the latest summary state if available, otherwise fallback
            const summaryText = summary?.summary || editedData.rawTextSummary;
            if (summaryText) {
                doc.setFontSize(12);
                doc.setFont("helvetica", "bold");
                doc.text("Summary", 14, currentY);
                currentY += 6;
                doc.setFont("helvetica", "normal");
                doc.setFontSize(10);
                const splitSummary = doc.splitTextToSize(summaryText, pageWidth - 28);
                doc.text(splitSummary, 14, currentY);
                currentY += splitSummary.length * 5 + 10;
            }

            // Key-Value Data (Flattened)
            const flattened = flattenObject(editedData);
            const kvEntries = Object.entries(flattened).filter(([_, v]) => !String(v).startsWith('[Table') && !String(v).startsWith('[List'));
            
            if (kvEntries.length > 0) {
                doc.setFontSize(12);
                doc.setFont("helvetica", "bold");
                doc.text("Key Data", 14, currentY);
                currentY += 2;

                const kvData = kvEntries.map(([k, v]) => [k, String(v)]);
                
                autoTable(doc, {
                    startY: currentY + 4,
                    head: [['Field', 'Value']],
                    body: kvData,
                    theme: 'striped',
                    headStyles: { fillColor: [66, 66, 66] },
                    styles: { fontSize: 9, cellPadding: 3 },
                    columnStyles: { 0: { fontStyle: 'bold', cellWidth: 70 } },
                    margin: { left: 14, right: 14 }
                });
                
                // @ts-ignore
                currentY = doc.lastAutoTable.finalY + 15;
            }

            // Tables
            const docTables = editedData.structuredData.tables || [];
            docTables.forEach(table => {
                if (currentY > pageHeight - 40) {
                    doc.addPage();
                    currentY = 20;
                }

                doc.setFontSize(12);
                doc.setFont("helvetica", "bold");
                doc.text(table.tableName || "Table Data", 14, currentY);
                
                const headers = table.headers || (table.rows.length > 0 ? Object.keys(table.rows[0]) : []);
                if (headers.length > 0) {
                    const body = table.rows.map((row: any) => headers.map((h: string) => {
                        const cell = row[h];
                        return String(cell?.value ?? cell ?? "");
                    }));

                    autoTable(doc, {
                        startY: currentY + 5,
                        head: [headers],
                        body: body,
                        theme: 'grid',
                        headStyles: { fillColor: [0, 122, 255] },
                        styles: { fontSize: 8 },
                        margin: { left: 14, right: 14 }
                    });
                    
                    // @ts-ignore
                    currentY = doc.lastAutoTable.finalY + 15;
                }
            });

            if (settings.showWatermark) {
                const totalPages = doc.getNumberOfPages();
                for (let i = 1; i <= totalPages; i++) {
                    doc.setPage(i);
                    doc.setFontSize(9);
                    doc.setTextColor(150);
                    doc.text(WATERMARK_TEXT, 14, pageHeight - 10);
                }
            }

            doc.save(fileName);
            setNotification({ message: 'PDF exported successfully!', type: 'success' });
        } catch (error) {
            console.error("PDF Export failed", error);
            setNotification({ message: 'Failed to generate PDF. Please try again.', type: 'error' });
        } finally {
            setIsExportingPDF(false);
        }
    };

    useEffect(() => {
        setIsTextDirty(false); 
        if (settings.showSummary) {
            setIsSummaryLoading(true);
            generateSummaryFromData(editedData).then(setSummary).finally(() => setIsSummaryLoading(false));
        }
    }, [editedData, settings.showSummary]);

    const computedHtml = useMemo(() => {
        return generateTextSummary(editedData, activeField);
    }, [editedData, activeField, generateTextSummary]);

    useEffect(() => {
        if (!isTextDirty) {
            setTextContent(computedHtml);
        }
    }, [computedHtml, isTextDirty]);

    useEffect(() => {
        if (activeFormat === 'text' && editorRef.current) {
            const contentToRender = isTextDirty ? textContent : computedHtml;
            if (editorRef.current.innerHTML !== contentToRender) {
                editorRef.current.innerHTML = contentToRender;
            }
        }
    }, [activeFormat, isTextDirty, textContent, computedHtml]);

    useEffect(() => {
        const editor = editorRef.current;
        if (!editor) return;
        const handleEditorClick = (e: MouseEvent) => {
            let target = e.target as HTMLElement;
            
            // 1. Check if Action Icon was clicked (in Text View)
            const actionBtn = target.closest('[data-action-type]');
            if (actionBtn) {
                e.preventDefault();
                e.stopPropagation();
                
                const type = actionBtn.getAttribute('data-action-type');
                const val = actionBtn.getAttribute('data-action-value');
                const key = actionBtn.getAttribute('data-action-key') || 'Event';
                
                if (type && val) {
                    if (type === 'email') window.open(`mailto:${val}`);
                    else if (type === 'phone') window.open(`tel:${val.replace(/[^\d+]/g, '')}`);
                    else if (type === 'map') window.open(`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(val.replace(/\n/g, ', '))}`, '_blank');
                    else if (type === 'calendar') {
                         const date = new Date(val);
                         if (!isNaN(date.getTime())) {
                            const iso = date.toISOString().replace(/-|:|\.\d+/g, '');
                            const dateStr = iso.slice(0, 8);
                            const datesParam = `${dateStr}/${dateStr}`;
                            const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(key)}&dates=${datesParam}&details=${encodeURIComponent('Value: ' + val)}`;
                            window.open(url, '_blank');
                         }
                    }
                }
                return;
            }

            // 2. Check if Field Line was clicked (Explain)
            // Handle clicks on children (like the svg icon or span text)
            if (!target.hasAttribute('data-field-name')) {
                const parent = target.closest('[data-field-name]');
                if (parent) target = parent as HTMLElement;
            }
            
            const fieldName = target.getAttribute('data-field-name');
            if (fieldName) {
                const fieldValue = target.innerText.replace(/[\uE000-\uF8FF]|\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F]/g, "").trim(); // basic strip
                triggerExplanation(fieldName, fieldValue);
            }
        };
        editor.addEventListener('click', handleEditorClick);
        return () => { editor.removeEventListener('click', handleEditorClick); };
    }, [triggerExplanation, activeFormat]);

    const isSearchable = activeFormat === 'key_value' || activeFormat === 'grid';
    
    // Determine if we have issues to show based on active format
    const hasIssues = activeFormat === 'key_value' 
        ? validationResult.issues.length > 0 
        : (activeFormat === 'grid' && gridValidationResult.issues.length > 0);
        
    const issueCount = activeFormat === 'key_value' 
        ? validationResult.issues.length 
        : gridValidationResult.issues.length;

    const renderData = (format: OutputFormat, dataToRender: ExtractedData) => {
        switch (format) {
            case 'json': return <div className="p-8 h-full overflow-auto ios-scroll"><pre className="text-xs font-mono text-gray-800 dark:text-gray-300 whitespace-pre-wrap">{JSON.stringify(dataToRender.structuredData, null, 2)}</pre></div>;
            case 'text': return (
                <div className="flex flex-col h-full bg-white dark:bg-zinc-900 relative rounded-2xl overflow-hidden">
                    {/* Rich Text Toolbar */}
                    <div className="flex items-center gap-1 p-2 border-b border-gray-100 dark:border-zinc-800 bg-gray-50/80 dark:bg-zinc-800/80 backdrop-blur-md z-10">
                        <Tooltip text="Align Left">
                            <button 
                                onClick={() => handleFormat('justifyLeft')} 
                                className={`p-1.5 rounded-lg transition-all ${textAlign === 'left' ? 'bg-white dark:bg-zinc-600 shadow-sm text-blue-600 dark:text-blue-400' : 'text-gray-500 hover:bg-gray-200 dark:hover:bg-zinc-700'}`}
                            >
                                <AlignLeftIcon className="w-4 h-4" />
                            </button>
                        </Tooltip>
                        <Tooltip text="Align Center">
                            <button 
                                onClick={() => handleFormat('justifyCenter')} 
                                className={`p-1.5 rounded-lg transition-all ${textAlign === 'center' ? 'bg-white dark:bg-zinc-600 shadow-sm text-blue-600 dark:text-blue-400' : 'text-gray-500 hover:bg-gray-200 dark:hover:bg-zinc-700'}`}
                            >
                                <AlignCenterIcon className="w-4 h-4" />
                            </button>
                        </Tooltip>
                        <Tooltip text="Align Right">
                            <button 
                                onClick={() => handleFormat('justifyRight')} 
                                className={`p-1.5 rounded-lg transition-all ${textAlign === 'right' ? 'bg-white dark:bg-zinc-600 shadow-sm text-blue-600 dark:text-blue-400' : 'text-gray-500 hover:bg-gray-200 dark:hover:bg-zinc-700'}`}
                            >
                                <AlignRightIcon className="w-4 h-4" />
                            </button>
                        </Tooltip>
                        
                        <div className="w-px h-4 bg-gray-300 dark:bg-zinc-700 mx-2"></div>
                        
                        <Tooltip text="Clear Formatting">
                            <button 
                                onClick={() => handleFormat('removeFormat')} 
                                className="p-1.5 rounded-lg text-gray-500 hover:bg-red-50 hover:text-red-500 dark:hover:bg-red-900/20 transition-all"
                            >
                                <ClearFormattingIcon className="w-4 h-4" />
                            </button>
                        </Tooltip>
                    </div>
                    
                    <div ref={editorRef} contentEditable onInput={(e) => { setTextContent(e.currentTarget.innerHTML); setIsTextDirty(true); }} className="flex-grow p-8 outline-none overflow-y-auto ios-scroll max-w-none text-gray-800 dark:text-gray-200 selection:bg-yellow-200/50 dark:selection:bg-yellow-900/30" style={{ fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace', fontSize: '0.9rem' }} />
                </div>
            );
            case 'key_value':
                const kvData = flattenObject(dataToRender);
                const entries = Object.entries(kvData);
                const filteredEntries = entries.filter(([key, value]) => {
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        if (!(key.toLowerCase().includes(q) || String(value).toLowerCase().includes(q))) return false;
                    }
                    if (showOnlyIssues) {
                        return validationResult.issues.some(issue => issue.involvedKeys.some(k => key.toLowerCase().includes(k.toLowerCase())));
                    }
                    return true;
                });
                if (filteredEntries.length === 0) return <div className="p-12 text-center text-gray-500 font-medium">No matching fields found.</div>;
                return (
                    <div className="flex flex-col h-full overflow-y-auto ios-scroll">
                        {!showOnlyIssues && validationResult.issues.length > 0 && (
                            <div className="mx-6 mt-6 p-4 bg-red-50 dark:bg-red-500/10 border border-red-200 dark:border-red-500/20 rounded-xl space-y-2">
                                <div className="flex items-center gap-2 mb-2">
                                     <ShieldCheckIcon className="w-5 h-5 text-red-500" />
                                     <h4 className="font-bold text-red-800 dark:text-red-300">Logic & Consistency Checks</h4>
                                </div>
                                {validationResult.issues.map((issue, idx) => (
                                    <div key={idx} className="flex items-start gap-2 text-sm text-red-700 dark:text-red-400 ml-1">
                                        <span className={`mt-1.5 w-1.5 h-1.5 rounded-full flex-shrink-0 ${issue.severity === 'error' ? 'bg-red-500' : 'bg-orange-500'}`}></span>
                                        <span>{issue.message}</span>
                                    </div>
                                ))}
                            </div>
                        )}
                        <div className="pb-6">
                            {filteredEntries.map(([key, value], idx) => {
                                 const rootKey = key.split(' > ').pop()?.toLowerCase() || '';
                                 const score = confidenceMap.get(key) || confidenceMap.get(rootKey); 
                                 const isVeryLowConfidence = score !== undefined && score < 80;
                                 
                                 const logicIssue = validationResult.issues.find(issue => issue.involvedKeys.some(k => key.toLowerCase().includes(k.toLowerCase())));
                                 const isLogicIssue = !!logicIssue;
                                 
                                 const isListSummary = typeof value === 'string' && (value.startsWith('[Table') || value.startsWith('[List'));
                                 const actionItem = getActionForValue(key, String(value));
                                 
                                 const isUnreadable = String(value) === '[Unreadable]';

                                 // Determine text color based on priority: Logic Error > Unreadable > Confidence Score
                                 let textColorClass = getConfidenceColor(score);
                                 if (isLogicIssue) {
                                     textColorClass = logicIssue?.severity === 'error' ? 'text-red-700 dark:text-red-300' : 'text-orange-700 dark:text-orange-300';
                                 }
                                 
                                 // Highlight unreadable fields prominently
                                 let finalInputClass = `text-base ${textColorClass}`;
                                 if (isUnreadable) {
                                     finalInputClass = `text-sm bg-red-100/80 dark:bg-red-900/40 text-red-600 dark:text-red-300 font-bold tracking-wide px-2 rounded border border-red-200 dark:border-red-800/50 italic shadow-sm`;
                                 }

                                 // Cleaner List Row Style
                                 return (
                                    <div 
                                        key={key} 
                                        className={`group relative flex items-start gap-4 px-6 py-4 border-b border-gray-100 dark:border-zinc-800/60 last:border-0 hover:bg-gray-50/50 dark:hover:bg-white/[0.02] transition-colors ${activeField === key ? 'bg-blue-50/30 dark:bg-blue-900/10' : ''}`}
                                    >
                                        <div className="w-1/3 min-w-[180px] max-w-[300px] flex-shrink-0 pt-1.5">
                                            <div className="flex items-center gap-2">
                                                {isLogicIssue && <ExclamationTriangleIcon className={`w-3.5 h-3.5 flex-shrink-0 ${logicIssue?.severity === 'error' ? 'text-red-500' : 'text-orange-500'}`} />}
                                                {!isLogicIssue && isVeryLowConfidence && !isUnreadable && <Tooltip text="Low Confidence"><ExclamationTriangleIcon className="w-3.5 h-3.5 text-amber-500 flex-shrink-0" /></Tooltip>}
                                                {isUnreadable && <Tooltip text="Content could not be read"><XMarkIcon className="w-3.5 h-3.5 text-red-500 flex-shrink-0" /></Tooltip>}
                                                <p className="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 break-words leading-relaxed" title={key}>{key}</p>
                                            </div>
                                            {settings.showConfidence && !isUnreadable && <div className="mt-1"><ConfidenceBadge score={score} /></div>}
                                        </div>
                                        
                                        <div className="flex-1 min-w-0 relative">
                                            <div className="flex items-start gap-2">
                                                <div className="flex-1">
                                                    <EditableInput
                                                        value={String(value)}
                                                        onChange={(e) => handleKeyValueChange(key, e.target.value)}
                                                        onBlur={(e) => handleInputBlur(key, e.target.value)}
                                                        onFocus={() => { setActiveField(key); setShowSplitView(true); }}
                                                        label={key}
                                                        isActive={activeField === key}
                                                        isEdited={editedFields.has(key)}
                                                        disabled={isListSummary}
                                                        className={finalInputClass}
                                                    />
                                                </div>
                                                
                                                {/* Action Buttons: Fade in on hover */}
                                                <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 focus-within:opacity-100 transition-opacity">
                                                    {actionItem && !isListSummary && !isUnreadable && (
                                                        <Tooltip text={actionItem.label} position="top">
                                                            <button onClick={actionItem.action} className="p-1.5 text-gray-400 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg transition-colors">
                                                                <actionItem.icon className="w-4 h-4" />
                                                            </button>
                                                        </Tooltip>
                                                    )}
                                                    {isListSummary ? (
                                                        <button onClick={() => setActiveFormat('grid')} className="p-1.5 text-gray-400 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg"><TableCellsIcon className="w-4 h-4" /></button>
                                                    ) : (
                                                        <Tooltip text="Explain extraction logic" position="left">
                                                            <button onClick={() => triggerExplanation(key, String(value))} className="p-1.5 text-gray-400 hover:text-amber-500 hover:bg-amber-50 dark:hover:bg-amber-900/20 rounded-lg transition-all"><LightBulbIcon className="w-4 h-4" /></button>
                                                        </Tooltip>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            case 'grid':
                if (tables.length === 0) return <div className="flex flex-col items-center justify-center h-full text-gray-500"><TableCellsIcon className="w-12 h-12 mb-3 opacity-20" /><p>No table structures detected.</p></div>;
                const currentTable = tables[activeTableIndex] || tables[0];
                if (!currentTable || !currentTable.data || currentTable.data.length === 0) return <div className="p-6 text-center text-gray-500">Empty table data.</div>;
                const keys = Object.keys(currentTable.data[0]);
                const filteredRows = currentTable.data.filter((row, i) => {
                    // Search Logic
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        // Unpack row values for search
                        const values = Object.values(row).map((v: any) => (v && typeof v === 'object' && 'value' in v) ? v.value : v);
                        if (!values.some(v => String(v).toLowerCase().includes(q))) return false;
                    }
                    // Filter Logic
                    if (showOnlyIssues) {
                        const rowHasIssue = gridValidationResult.issues.some(issue => issue.rowIndex === i);
                        if (!rowHasIssue) return false;
                    }
                    return true;
                });
                if (filteredRows.length === 0) return <div className="p-12 text-center text-gray-500 font-medium">No matching table rows found.</div>;
                
                return (
                    <div className="flex flex-col h-full bg-white dark:bg-zinc-900">
                        {/* Table Selector Tabs */}
                        {tables.length > 1 && (
                            <div className="flex items-center gap-2 p-3 border-b border-gray-100 dark:border-zinc-800/60 overflow-x-auto no-scrollbar">
                                {tables.map((tbl, idx) => (
                                    <button
                                        key={tbl.id}
                                        onClick={() => setActiveTableIndex(idx)}
                                        className={`px-4 py-2 text-xs font-bold rounded-lg whitespace-nowrap transition-all ${activeTableIndex === idx ? 'bg-blue-50 dark:bg-blue-900/30 text-blue-600 dark:text-blue-300' : 'text-gray-500 hover:bg-gray-50 dark:hover:bg-zinc-800'}`}
                                    >
                                        {tbl.name}
                                    </button>
                                ))}
                            </div>
                        )}
                        
                        <div className="flex-1 overflow-auto ios-scroll relative">
                            <table ref={tableRef} className="w-full border-collapse text-left text-sm relative">
                                <thead className="sticky top-0 z-10 bg-gray-50/95 dark:bg-zinc-800/95 backdrop-blur-sm shadow-sm">
                                    <tr>
                                        <th className="p-3 w-10 text-center font-semibold text-gray-400 border-b border-gray-200 dark:border-zinc-700">#</th>
                                        {keys.map(k => <th key={k} className="p-3 font-semibold text-gray-600 dark:text-gray-300 uppercase tracking-wider text-[11px] border-b border-gray-200 dark:border-zinc-700 min-w-[150px]">{k}</th>)}
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-gray-100 dark:divide-zinc-800/60">
                                    {filteredRows.map((row, i) => {
                                        const originalIndex = currentTable.data.indexOf(row);
                                        const rowIssues = gridValidationResult.issues.filter(issue => issue.rowIndex === originalIndex);
                                        const hasRowError = rowIssues.some(issue => issue.severity === 'error');
                                        const hasRowWarning = rowIssues.some(issue => issue.severity === 'warning');
                                        
                                        return (
                                            <tr key={i} className={`group hover:bg-gray-50/80 dark:hover:bg-white/[0.02] transition-colors ${hasRowError ? 'bg-red-50/30 dark:bg-red-900/10' : (hasRowWarning ? 'bg-orange-50/30 dark:bg-orange-900/10' : '')}`}>
                                                <td className="p-3 text-center text-xs font-mono text-gray-400 border-r border-dashed border-gray-100 dark:border-zinc-800/60 select-none">
                                                    {originalIndex + 1}
                                                    {(hasRowError || hasRowWarning) && (
                                                        <Tooltip text={rowIssues.map(i => i.message).join('\n')} position="right">
                                                            <div className="mt-1 flex justify-center">
                                                                <ExclamationTriangleIcon className={`w-3 h-3 ${hasRowError ? 'text-red-500' : 'text-orange-500'}`} />
                                                            </div>
                                                        </Tooltip>
                                                    )}
                                                </td>
                                                {keys.map(k => {
                                                    const cellData = row[k];
                                                    const cellValue = (cellData && typeof cellData === 'object' && 'value' in cellData) ? cellData.value : cellData;
                                                    const cellScore = (cellData && typeof cellData === 'object' && 'confidence' in cellData) ? cellData.confidence : undefined;
                                                    const confidenceColor = getConfidenceColor(cellScore);

                                                    const cellKey = `${currentTable.path || 'root'}-${originalIndex}-${k}`;
                                                    const isEdited = editedFields.has(cellKey);
                                                    
                                                    const actionItem = getActionForValue(k, String(cellValue));
                                                    const isUnreadable = String(cellValue) === '[Unreadable]';

                                                    let gridInputClass = `px-2 ${confidenceColor} ${actionItem ? 'pr-7' : ''}`;
                                                    if (isUnreadable) {
                                                        gridInputClass = `px-2 pr-7 bg-red-100/80 dark:bg-red-900/40 text-red-600 dark:text-red-300 font-bold text-xs border border-red-200 dark:border-red-800/50 rounded italic`;
                                                    }

                                                    return (
                                                        <td key={k} className="p-2 border-r border-dashed border-gray-100 dark:border-zinc-800/60 last:border-0 relative group/cell">
                                                            <div className="relative flex items-center w-full h-full">
                                                                <EditableInput
                                                                    value={String(cellValue ?? '')}
                                                                    onChange={(e) => handleGridChange(originalIndex, k, e.target.value)}
                                                                    onBlur={(e) => handleInputBlur(k, e.target.value, originalIndex)}
                                                                    label={`${k} row ${originalIndex + 1}`}
                                                                    isEdited={isEdited}
                                                                    onFocus={() => setShowSplitView(true)}
                                                                    className={gridInputClass}
                                                                />
                                                                
                                                                {/* Floating Action Bar for Cell */}
                                                                <div className="absolute right-1 top-1/2 -translate-y-1/2 opacity-0 group-hover/cell:opacity-100 transition-opacity z-10 flex gap-1 bg-white/90 dark:bg-zinc-800/90 backdrop-blur-sm rounded-md shadow-sm border border-black/5 dark:border-white/5 p-0.5">
                                                                    {actionItem && !isUnreadable && (
                                                                        <Tooltip text={actionItem.label} position="top">
                                                                            <button 
                                                                                onClick={actionItem.action}
                                                                                className="p-1 text-gray-400 hover:text-[#007AFF] rounded hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all hover:scale-110"
                                                                            >
                                                                                <actionItem.icon className="w-3 h-3" />
                                                                            </button>
                                                                        </Tooltip>
                                                                    )}
                                                                    
                                                                    {/* Explain Button in Grid */}
                                                                    {!isUnreadable && (
                                                                        <Tooltip text="Explain extraction logic" position="top">
                                                                            <button 
                                                                                onClick={() => triggerExplanation(k, String(cellValue))}
                                                                                className="p-1 text-gray-400 hover:text-amber-500 rounded hover:bg-amber-50 dark:hover:bg-amber-900/20 transition-all hover:scale-110"
                                                                            >
                                                                                <LightBulbIcon className="w-3 h-3" />
                                                                            </button>
                                                                        </Tooltip>
                                                                    )}
                                                                </div>

                                                                {isUnreadable && (
                                                                    <div className="absolute right-1 top-1/2 -translate-y-1/2 z-10 pointer-events-none">
                                                                        <XMarkIcon className="w-3 h-3 text-red-500 opacity-60" />
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div>
                        <div className="p-3 border-t border-gray-100 dark:border-zinc-800 flex justify-between items-center bg-white dark:bg-zinc-900 text-xs">
                            <span className="text-gray-500">{filteredRows.length} rows visible</span>
                            <button onClick={() => exportTableToCSV(currentTable)} className="font-bold text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 px-3 py-1.5 rounded-lg transition-all flex items-center gap-1.5">
                                <ArrowDownTrayIcon className="w-3.5 h-3.5" />
                                Download CSV
                            </button>
                        </div>
                    </div>
                );
            default: return null;
        }
    };

    return (
        <>
            <div className="flex flex-col h-full bg-white dark:bg-zinc-900 relative">
                {/* --- Toolbar --- */}
                <div className="h-16 px-6 flex items-center justify-between border-b border-gray-100 dark:border-zinc-800 bg-white/80 dark:bg-zinc-900/80 backdrop-blur-md z-20 flex-shrink-0">
                    {/* View Switcher */}
                    <div className="flex bg-gray-100/80 dark:bg-zinc-800/80 p-1 rounded-xl">
                        {outputFormats.map(fmt => (
                            <Tooltip key={fmt.id} text={fmt.tooltip}>
                                <button
                                    onClick={() => setActiveFormat(fmt.id)}
                                    className={`px-4 py-2 text-xs font-bold rounded-lg transition-all duration-300 ${
                                        activeFormat === fmt.id
                                            ? 'bg-white dark:bg-zinc-700 text-black dark:text-white shadow-sm'
                                            : 'text-gray-500 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
                                    }`}
                                >
                                    {fmt.label}
                                </button>
                            </Tooltip>
                        ))}
                    </div>

                    {/* Search & Actions */}
                    <div className="flex items-center gap-3">
                        {isSearchable && (
                            <div className="relative group">
                                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                    <MagnifyingGlassIcon className="h-4 w-4 text-gray-400 group-focus-within:text-[#007AFF] transition-colors" />
                                </div>
                                <input
                                    type="text"
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    placeholder="Search data..."
                                    className="pl-9 pr-8 py-2 w-48 bg-gray-50 dark:bg-zinc-800 border border-transparent focus:bg-white dark:focus:bg-black focus:border-[#007AFF]/30 focus:ring-4 focus:ring-[#007AFF]/10 rounded-xl text-xs font-medium transition-all outline-none"
                                />
                                {searchQuery && (
                                    <button onClick={() => setSearchQuery('')} className="absolute inset-y-0 right-0 pr-2 flex items-center text-gray-400 hover:text-gray-600">
                                        <XMarkIcon className="h-3.5 w-3.5" />
                                    </button>
                                )}
                            </div>
                        )}
                        
                        {hasIssues && (
                            <Tooltip text="Filter to only show fields with issues">
                                <button
                                    onClick={() => setShowOnlyIssues(!showOnlyIssues)}
                                    className={`p-2 rounded-xl transition-all border ${showOnlyIssues ? 'bg-red-50 border-red-200 text-red-600' : 'bg-white border-gray-200 text-gray-400 hover:border-red-300 hover:text-red-500'}`}
                                >
                                    <ExclamationTriangleIcon className="w-4 h-4" />
                                </button>
                            </Tooltip>
                        )}

                        <div className="w-px h-6 bg-gray-200 dark:bg-zinc-700 mx-1"></div>

                        <Tooltip text="Toggle Split View">
                            <button
                                onClick={() => setShowSplitView(!showSplitView)}
                                className={`p-2 rounded-xl transition-all ${showSplitView ? 'bg-[#007AFF] text-white shadow-lg shadow-blue-500/30' : 'bg-gray-100 dark:bg-zinc-800 text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-zinc-700'}`}
                            >
                                <ViewColumnsIcon className="w-4 h-4" />
                            </button>
                        </Tooltip>
                    </div>
                </div>

                {/* --- Main Content Area --- */}
                <div className="flex-1 overflow-hidden relative flex">
                    {/* Data Panel */}
                    <div ref={resultsContentRef} className="flex-1 h-full min-w-0 flex flex-col bg-white dark:bg-zinc-900">
                        {settings.showSummary && activeFormat === 'text' && (
                            <div className="px-8 pt-6 pb-2">
                                <AISummary summary={summary} loading={isSummaryLoading} onRegenerate={handleRegenerateSummary} onExplain={handleExplainSummary} />
                            </div>
                        )}
                        {renderData(activeFormat, editedData)}
                    </div>

                    {/* Split View Panel (Document Highlighter) */}
                    <div className={`transition-all duration-500 ease-[cubic-bezier(0.32,0.72,0,1)] border-l border-gray-200 dark:border-zinc-800 bg-gray-50/50 dark:bg-black/20 backdrop-blur-xl absolute top-0 bottom-0 right-0 z-30 shadow-2xl ${showSplitView ? 'w-[45%] translate-x-0' : 'w-[45%] translate-x-full pointer-events-none opacity-0'}`}>
                        <div className="h-full flex flex-col">
                            <div className="h-12 flex items-center justify-between px-4 border-b border-gray-200 dark:border-zinc-800 bg-white/80 dark:bg-zinc-900/80 backdrop-blur-md">
                                <span className="text-xs font-bold uppercase tracking-wider text-gray-500">Source Document</span>
                                <button onClick={() => setShowSplitView(false)} className="p-1.5 hover:bg-gray-100 dark:hover:bg-zinc-800 rounded-lg text-gray-400 transition-colors">
                                    <XMarkIcon className="w-4 h-4" />
                                </button>
                            </div>
                            <div className="flex-1 relative overflow-hidden">
                                {file.file.type.startsWith('image/') ? (
                                    <DocumentHighlighter 
                                        file={file} 
                                        highlights={initialData.highlights || []} 
                                        hoveredField={activeField} 
                                        activeField={activeField} 
                                        onHoverField={setActiveField} 
                                        showHighlights={true} 
                                    />
                                ) : (
                                    <div className="flex items-center justify-center h-full text-gray-400 flex-col gap-2">
                                        <PhotoIcon className="w-12 h-12 opacity-20" />
                                        <p className="text-xs">Preview available for images only</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
                
                {/* --- Bottom Action Bar --- */}
                <div className="h-14 border-t border-gray-100 dark:border-zinc-800 bg-white dark:bg-zinc-900 flex items-center justify-between px-6 flex-shrink-0 z-20">
                    <div className="flex items-center gap-4 text-xs font-medium text-gray-500">
                        {activeFormat === 'grid' ? (
                            <span>{tables.length} tables found</span>
                        ) : (
                            <span>{Object.keys(flattenObject(editedData)).length} fields extracted</span>
                        )}
                        {issueCount > 0 && (
                            <span className="flex items-center gap-1.5 text-orange-600 bg-orange-50 px-2 py-0.5 rounded-full">
                                <ExclamationTriangleIcon className="w-3.5 h-3.5" />
                                {issueCount} Issues
                            </span>
                        )}
                    </div>
                    
                    <div className="flex items-center gap-3">
                        <button 
                            onClick={handleExportPDF} 
                            disabled={isExportingPDF}
                            className="text-xs font-bold text-gray-600 hover:text-[#007AFF] transition-colors flex items-center gap-1.5 disabled:opacity-50"
                        >
                            {isExportingPDF ? (
                                <>
                                    <span className="w-3 h-3 border-2 border-current border-t-transparent rounded-full animate-spin"></span>
                                    Generating PDF...
                                </>
                            ) : (
                                <>
                                    <ArrowDownTrayIcon className="w-3.5 h-3.5" />
                                    Export PDF
                                </>
                            )}
                        </button>
                        <div className="h-4 w-px bg-gray-300 dark:bg-zinc-700"></div>
                        <button onClick={() => setIsTemplateModalOpen(true)} className="text-xs font-bold text-gray-600 hover:text-[#007AFF] transition-colors">
                            Save as Template
                        </button>
                        <div className="h-4 w-px bg-gray-300 dark:bg-zinc-700"></div>
                        <button onClick={() => onReprocess(editedData)} className="text-xs font-bold text-[#007AFF] hover:bg-[#007AFF]/10 px-3 py-1.5 rounded-lg transition-colors">
                            Re-Run Extraction
                        </button>
                    </div>
                </div>
            </div>

            <SaveTemplateModal isOpen={isTemplateModalOpen} onClose={() => setIsTemplateModalOpen(false)} onSave={(name) => { setNotification({ message: `Template "${name}" saved!`, type: 'success' }); setIsTemplateModalOpen(false); }} />
            
            <ExplanationModal 
                isOpen={isExplanationModalOpen} 
                onClose={() => setIsExplanationModalOpen(false)} 
                target={explanationTarget} 
                explanation={explanationContent} 
                isLoading={isExplanationLoading} 
            />

            {notification && <Notification message={notification.message} type={notification.type} onClose={() => setNotification(null)} action={notification.action} />}
        </>
    );
};
