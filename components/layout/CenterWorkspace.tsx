
import React, { useState, useCallback, useMemo, useEffect, useRef, useContext } from 'react';
import type { ExtractedData, OutputFormat, UploadedFile, AISummaryData } from '../../types';
import { generateSummaryFromData, getExplanationForField } from '../../services/geminiService';
import { autoFormatValue, validateDocumentLogic } from '../../utils/validationUtils';
import { SettingsContext } from '../../contexts/SettingsContext';
import { useClickOutside } from '../../hooks/useClickOutside';
import { AISummary } from '../AISummary';
import { SaveTemplateModal } from '../ui/SaveTemplateModal';
import { TableCellsIcon } from '../icons/TableCellsIcon';
import { PhotoIcon } from '../icons/PhotoIcon';
import { ViewColumnsIcon } from '../icons/ViewColumnsIcon';
import { ExclamationTriangleIcon } from '../icons/ExclamationTriangleIcon';
import { DocumentHighlighter } from '../DocumentHighlighter';
import { ShieldCheckIcon } from '../icons/ShieldCheckIcon';
import { flattenObject, extractTables, updateNestedState, updateTableData, DiscoveredTable } from '../../utils/dataAdapter';
import { formatAsOfficialDocument } from '../../utils/textFormatter';
import { MagnifyingGlassIcon } from '../icons/MagnifyingGlassIcon';
import { XMarkIcon } from '../icons/XMarkIcon';
import { Notification } from '../ui/Notification';
import { logAuditEvent } from '../../utils/auditLogger';
import { LightBulbIcon } from '../icons/LightBulbIcon';
import { ExplanationModal } from '../ui/ExplanationModal';
import { Tooltip } from '../ui/Tooltip';
import { CalendarIcon } from '../icons/CalendarIcon';
import { MapPinIcon } from '../icons/MapPinIcon';
import { EnvelopeIcon } from '../icons/EnvelopeIcon';
import { PhoneIcon } from '../icons/PhoneIcon';
import { ArrowDownTrayIcon } from '../icons/ArrowDownTrayIcon';

interface CenterWorkspaceProps {
    initialData: ExtractedData;
    editedData: ExtractedData;
    onDataChange: (newData: ExtractedData) => void;
    file: UploadedFile;
    onNewUpload: () => void;
    onReprocess: (editedData: ExtractedData) => void;
}

const WATERMARK_TEXT = "Generated by DataExtract AI";

const outputFormats: { id: OutputFormat; label: string; tooltip: string }[] = [
    { id: 'key_value', label: 'Key-Value', tooltip: 'Flat data mapping' },
    { id: 'grid', label: 'Grid', tooltip: 'Tabular spreadsheet view' },
    { id: 'text', label: 'Report', tooltip: 'Official document text' },
    { id: 'json', label: 'JSON', tooltip: 'Raw technical structure' },
];

const ConfidenceBadge: React.FC<{ score: number | undefined }> = ({ score }) => {
    if (score === undefined) return null;
    let colorClass = 'bg-[#FF3B30] text-white'; 
    if (score >= 85) colorClass = 'bg-[#34C759] text-white';
    else if (score >= 60) colorClass = 'bg-[#FF9500] text-white'; 

    return (
        <span className={`inline-flex items-center px-1.5 py-0.5 rounded-full text-[10px] font-bold ${colorClass} ml-2 flex-shrink-0 animate-fade-in`}>
            {score}%
        </span>
    );
};

const EditableInput = ({ 
    value, onChange, onBlur, label, onFocus, isActive, isEdited, className, disabled 
}: { 
    value: string; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void; label: string; onFocus?: () => void; isActive?: boolean; isEdited?: boolean; className?: string; disabled?: boolean;
}) => (
    <input
        type="text"
        value={value}
        onChange={onChange}
        onFocus={onFocus}
        onBlur={onBlur}
        aria-label={label}
        disabled={disabled}
        className={`w-full bg-transparent p-0 m-0 border-none focus:ring-1 focus:ring-blue-500 focus:bg-blue-500/10 rounded-md px-1 dark:text-gray-200 cursor-pointer transition-all ${isActive ? 'bg-blue-500/20 ring-2 ring-blue-500 ring-offset-2 dark:ring-offset-zinc-800' : ''} ${isEdited ? 'bg-yellow-100 dark:bg-yellow-500/20' : ''} ${disabled ? 'cursor-not-allowed opacity-70 text-gray-500 italic' : ''} ${className || ''}`}
    />
);

export const CenterWorkspace: React.FC<CenterWorkspaceProps> = ({ initialData, editedData, onDataChange, file, onNewUpload, onReprocess }) => {
    const { settings } = useContext(SettingsContext);
    const [activeFormat, setActiveFormat] = useState<OutputFormat>('key_value');
    const [editedFields, setEditedFields] = useState(new Set<string>());
    const [isTemplateModalOpen, setIsTemplateModalOpen] = useState(false);
    const [textContent, setTextContent] = useState('');
    const [isTextDirty, setIsTextDirty] = useState(false);
    const [summary, setSummary] = useState<AISummaryData | null>(null);
    const [isSummaryLoading, setIsSummaryLoading] = useState<boolean>(true);
    const [activeField, setActiveField] = useState<string | null>(null);
    const [notification, setNotification] = useState<{ message: string; type: 'success' | 'error' | 'info'; action?: any } | null>(null);
    const [isExplanationModalOpen, setIsExplanationModalOpen] = useState(false);
    const [explanationTarget, setExplanationTarget] = useState<{ fieldName: string; fieldValue?: string } | null>(null);
    const [explanationContent, setExplanationContent] = useState<string | null>(null);
    const [isExplanationLoading, setIsExplanationLoading] = useState(false);
    const [showSplitView, setShowSplitView] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [showOnlyIssues, setShowOnlyIssues] = useState(false);
    
    // Table Discovery State using Adapter
    const [activeTableIndex, setActiveTableIndex] = useState(0);
    const tables = useMemo(() => extractTables(editedData), [editedData]);

    const tableRef = useRef<HTMLTableElement>(null);
    const editorRef = useRef<HTMLDivElement>(null);
    const resultsContentRef = useRef<HTMLDivElement>(null);

    const validationResult = useMemo(() => validateDocumentLogic(flattenObject(editedData)), [editedData]);
    
    // Reset table index if data structure changes significantly
    useEffect(() => {
        if (activeTableIndex >= tables.length && tables.length > 0) {
            setActiveTableIndex(0);
        }
    }, [tables.length, activeTableIndex]);
    
    useEffect(() => {
        setSearchQuery('');
        setShowOnlyIssues(false);
    }, [activeFormat]);

    const confidenceMap = useMemo(() => {
        const map = new Map<string, number>();
        initialData.highlights?.forEach(h => { map.set(h.fieldName, h.confidence); });
        return map;
    }, [initialData.highlights]);

    const handleKeyValueChange = (flattenedKey: string, value: string) => {
        onDataChange(updateNestedState(editedData, flattenedKey, value));
        setEditedFields(prev => new Set(prev).add(flattenedKey));
        
        logAuditEvent('EDIT', settings.systemMode, {
            documentId: editedData.documentType,
            fieldsEdited: [flattenedKey],
            newValue: value
        });
    };

    const handleGridChange = (rowIndex: number, key: string, value: string) => {
        const currentTable = tables[activeTableIndex];
        if (!currentTable) return;

        onDataChange(updateTableData(editedData, currentTable.path, rowIndex, key, value));
        const cellKey = `${currentTable.path || 'root'}-${rowIndex}-${key}`;
        setEditedFields(prev => new Set(prev).add(cellKey));

        logAuditEvent('EDIT', settings.systemMode, {
            documentId: editedData.documentType,
            fieldsEdited: [cellKey],
            newValue: value
        });
    };

    const handleInputBlur = (key: string, value: string, rowIndex?: number) => {
        const formatted = autoFormatValue(key, value);
        if (formatted !== value) {
            if (rowIndex !== undefined) {
                handleGridChange(rowIndex, key, formatted);
            } else {
                handleKeyValueChange(key, formatted);
            }
            setNotification({ message: 'Auto-formatted value for consistency', type: 'info' });
        }
    };

    // --- Action Button Logic ---
    const getActionForValue = (key: string, value: string) => {
        if (!value || typeof value !== 'string') return null;
        const lowerKey = key.toLowerCase();
        
        // 1. Email
        if (lowerKey.includes('email') || /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
             if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
                return { icon: EnvelopeIcon, label: "Send Email", action: () => window.open(`mailto:${value}`) };
             }
        }
        // 2. Phone
        if ((lowerKey.includes('phone') || lowerKey.includes('mobile') || lowerKey.includes('fax') || lowerKey.includes('contact')) && value.length > 5 && /[0-9]/.test(value)) {
            return { icon: PhoneIcon, label: "Call", action: () => window.open(`tel:${value.replace(/[^\d+]/g, '')}`) };
        }
        // 3. Date -> Google Calendar
        if ((lowerKey.includes('date') || lowerKey.includes('due') || lowerKey.includes('expires') || lowerKey.includes('schedule')) && !isNaN(Date.parse(value)) && /\d/.test(value)) {
            return {
                icon: CalendarIcon, label: "Add to Calendar",
                action: () => {
                    const date = new Date(value);
                    if (isNaN(date.getTime())) return;
                    const iso = date.toISOString().replace(/-|:|\.\d+/g, '');
                    const dateStr = iso.slice(0, 8);
                    const datesParam = `${dateStr}/${dateStr}`;
                    const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(key)}&dates=${datesParam}&details=${encodeURIComponent('Value: ' + value + '\nSource: ' + editedData.documentType)}`;
                    window.open(url, '_blank');
                }
            };
        }
        // 4. Address -> Google Maps
        if ((lowerKey.includes('address') || lowerKey.includes('location') || lowerKey.includes('city') || lowerKey.includes('street') || lowerKey.includes('venue')) && value.length > 5) {
            if (!value.includes('http') && !/^[0-9]+$/.test(value)) {
                return { icon: MapPinIcon, label: "Open Maps", action: () => window.open(`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(value.replace(/\n/g, ', '))}`, '_blank') };
            }
        }
        return null;
    };

    const generateTextSummary = useCallback((dataToSummarize: ExtractedData, currentActiveField: string | null): string => {
        const dateStr = new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
        let html = `<div style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; line-height: 1.6; color: inherit;">`;
        html += `<h1 style="font-size: 1.25em; font-weight: 800; margin-bottom: 0.5em; text-transform: uppercase;">${dataToSummarize.documentType}</h1>`;
        html += `<div style="opacity: 0.5; margin-bottom: 1em;">------------------------------------</div>`;
        html += `<div style="margin-bottom: 1.5em;">Date: ${dateStr}<br/>Confidence Score: ${dataToSummarize.confidenceScore}%</div>`;
        if (dataToSummarize.rawTextSummary) {
             html += `<div style="margin-bottom: 1.5em; font-style: italic;">"${dataToSummarize.rawTextSummary}"</div>`;
        }
        const createValueSpan = (key: string, val: any) => {
            const strVal = String(val);
            const isActive = currentActiveField === key;
            const bgClass = isActive ? 'background-color: rgba(255, 215, 0, 0.3);' : '';
            return `<span data-field-name="${key}" style="${bgClass} cursor: pointer; text-decoration: underline; text-decoration-style: dotted; text-decoration-color: rgba(100,100,100,0.5);">${strVal}</span>`;
        };
        const kvData = flattenObject(dataToSummarize);
        Object.entries(kvData).forEach(([k, v]) => { html += `<div><strong>${k}:</strong> ${createValueSpan(k, v)}</div>`; });
        html += `<div style="margin-top: 2em; opacity: 0.5;">------------------------------------</div>`;
        html += `<div>End of Report</div></div>`;
        return html;
    }, []);

    const triggerExplanation = useCallback(async (fieldName: string, fieldValue: string) => {
        setExplanationTarget({ fieldName, fieldValue });
        setIsExplanationLoading(true);
        setIsExplanationModalOpen(true);
        setActiveField(fieldName);
        try {
            const result = await getExplanationForField(fieldName, fieldValue, [file]);
            setExplanationContent(result);
        } catch {
            setExplanationContent("Could not retrieve field explanation.");
        } finally {
            setIsExplanationLoading(false);
        }
    }, [file]);

    const handleRegenerateSummary = useCallback(async () => {
        setIsSummaryLoading(true);
        try {
            const newSummary = await generateSummaryFromData(editedData, true);
            setSummary(newSummary);
        } catch (error) {
            setNotification({ message: "Failed to regenerate summary.", type: 'error' });
        } finally {
            setIsSummaryLoading(false);
        }
    }, [editedData]);

    const handleExplainSummary = useCallback(async () => {
        if (!summary) return;
        setExplanationTarget({ fieldName: "Intelligent Summary" });
        setIsExplanationLoading(true);
        setIsExplanationModalOpen(true);
        try {
            const result = await getExplanationForField("The entire document content", summary.summary, [file]);
            setExplanationContent(result);
        } catch {
            setExplanationContent("Failed to generate an explanation for the summary.");
        } finally {
            setIsExplanationLoading(false);
        }
    }, [summary, file]);

    const exportTableToCSV = (table: DiscoveredTable) => {
        if (!table.data || table.data.length === 0) return;
        const headers = Object.keys(table.data[0]);
        const rows = table.data.map(row => headers.map(header => {
            const val = row[header];
            const str = String(val ?? '').replace(/"/g, '""');
            return `"${str}"`;
        }).join(','));
        const csvContent = [headers.join(','), ...rows].join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `${table.name || 'table'}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    useEffect(() => {
        setIsTextDirty(false); 
        if (settings.showSummary) {
            setIsSummaryLoading(true);
            generateSummaryFromData(editedData).then(setSummary).finally(() => setIsSummaryLoading(false));
        }
    }, [editedData, settings.showSummary]);

    const computedHtml = useMemo(() => {
        return generateTextSummary(editedData, activeField);
    }, [editedData, activeField, generateTextSummary]);

    useEffect(() => {
        if (!isTextDirty) {
            setTextContent(computedHtml);
        }
    }, [computedHtml, isTextDirty]);

    useEffect(() => {
        if (activeFormat === 'text' && editorRef.current) {
            const contentToRender = isTextDirty ? textContent : computedHtml;
            if (editorRef.current.innerHTML !== contentToRender) {
                editorRef.current.innerHTML = contentToRender;
            }
        }
    }, [activeFormat, isTextDirty, textContent, computedHtml]);

    useEffect(() => {
        const editor = editorRef.current;
        if (!editor) return;
        const handleEditorClick = (e: MouseEvent) => {
            const target = e.target as HTMLElement;
            const fieldName = target.getAttribute('data-field-name');
            if (fieldName) {
                const fieldValue = target.innerText;
                triggerExplanation(fieldName, fieldValue);
            }
        };
        editor.addEventListener('click', handleEditorClick);
        return () => { editor.removeEventListener('click', handleEditorClick); };
    }, [triggerExplanation, activeFormat]);

    const isSearchable = activeFormat === 'key_value' || activeFormat === 'grid';

    const renderData = (format: OutputFormat, dataToRender: ExtractedData) => {
        switch (format) {
            case 'json': return <div className="p-6 h-full overflow-auto ios-scroll"><pre className="text-sm font-mono text-gray-800 dark:text-gray-300">{JSON.stringify(dataToRender.structuredData, null, 2)}</pre></div>;
            case 'text': return (
                <div className="flex flex-col h-full bg-white dark:bg-zinc-900 relative">
                    <div ref={editorRef} contentEditable onInput={(e) => { setTextContent(e.currentTarget.innerHTML); setIsTextDirty(true); }} className="flex-grow p-10 outline-none overflow-y-auto ios-scroll max-w-none min-h-[400px] text-gray-800 dark:text-gray-200 selection:bg-yellow-200/50 dark:selection:bg-yellow-900/30" style={{ fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace', fontSize: '0.9rem' }} />
                </div>
            );
            case 'key_value':
                const kvData = flattenObject(dataToRender);
                const entries = Object.entries(kvData);
                const filteredEntries = entries.filter(([key, value]) => {
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        if (!(key.toLowerCase().includes(q) || String(value).toLowerCase().includes(q))) return false;
                    }
                    if (showOnlyIssues) {
                        return validationResult.issues.some(issue => issue.involvedKeys.some(k => key.toLowerCase().includes(k.toLowerCase())));
                    }
                    return true;
                });
                if (filteredEntries.length === 0) return <div className="p-12 text-center text-gray-500 font-medium">No matching fields found.</div>;
                return (
                    <div className="p-6 space-y-4 h-full overflow-auto ios-scroll">
                        {!showOnlyIssues && validationResult.issues.length > 0 && (
                            <div className="mb-6 p-4 bg-red-50 dark:bg-red-500/10 border border-red-200 dark:border-red-500/20 rounded-xl space-y-2">
                                <div className="flex items-center gap-2 mb-2">
                                     <ShieldCheckIcon className="w-5 h-5 text-red-500" />
                                     <h4 className="font-bold text-red-800 dark:text-red-300">Logic & Consistency Checks</h4>
                                </div>
                                {validationResult.issues.map((issue, idx) => (
                                    <div key={idx} className="flex items-start gap-2 text-sm text-red-700 dark:text-red-400 ml-1">
                                        <span className={`mt-1.5 w-1.5 h-1.5 rounded-full flex-shrink-0 ${issue.severity === 'error' ? 'bg-red-500' : 'bg-orange-500'}`}></span>
                                        <span>{issue.message}</span>
                                    </div>
                                ))}
                            </div>
                        )}
                        {filteredEntries.map(([key, value]) => {
                             const rootKey = key.split(' > ').pop()?.toLowerCase() || '';
                             const score = confidenceMap.get(key) || confidenceMap.get(rootKey); 
                             const isLowConfidence = score !== undefined && score < 90;
                             const isVeryLowConfidence = score !== undefined && score < 80;
                             const logicIssue = validationResult.issues.find(issue => issue.involvedKeys.some(k => key.toLowerCase().includes(k.toLowerCase())));
                             const isLogicIssue = !!logicIssue;
                             const issueColorClass = logicIssue?.severity === 'error' ? 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-900/30' : 'bg-orange-50 dark:bg-orange-900/10 border-orange-200 dark:border-orange-900/30';
                             const isListSummary = typeof value === 'string' && (value.startsWith('[Table') || value.startsWith('[List'));
                             const actionItem = getActionForValue(key, String(value));

                             return (
                                <div key={key} className={`flex items-center justify-between p-3 rounded-2xl border transition-all group ${activeField === key ? 'border-blue-500 ring-2 ring-blue-500/20' : 'border-black/5 dark:border-white/5'} ${isLogicIssue ? issueColorClass : (isLowConfidence ? 'bg-amber-50 dark:bg-amber-500/10' : 'bg-gray-50/50 dark:bg-zinc-800/50')}`}>
                                    <div className="flex items-center gap-2 overflow-hidden w-1/3">
                                        {isLogicIssue && <ExclamationTriangleIcon className={`w-4 h-4 flex-shrink-0 ${logicIssue?.severity === 'error' ? 'text-red-500' : 'text-orange-500'}`} />}
                                        {!isLogicIssue && isVeryLowConfidence && <Tooltip text="Low Confidence"><ExclamationTriangleIcon className="w-4 h-4 text-amber-500 flex-shrink-0" /></Tooltip>}
                                        <span className="text-sm font-bold uppercase tracking-wider truncate" title={key}>{key}</span>
                                        {settings.showConfidence && <ConfidenceBadge score={score} />}
                                    </div>
                                    <div className="text-sm font-medium ml-4 flex-1 flex items-center gap-2">
                                        <div className="flex-1 flex items-center gap-2">
                                            <EditableInput
                                                value={String(value)}
                                                onChange={(e) => handleKeyValueChange(key, e.target.value)}
                                                onBlur={(e) => handleInputBlur(key, e.target.value)}
                                                onFocus={() => { setActiveField(key); setShowSplitView(true); }}
                                                label={key}
                                                isActive={activeField === key}
                                                isEdited={editedFields.has(key)}
                                                disabled={isListSummary}
                                                className={isLogicIssue ? (logicIssue?.severity === 'error' ? 'text-red-900 dark:text-red-100' : 'text-orange-900 dark:text-orange-100') : (isLowConfidence ? 'text-amber-900 dark:text-amber-100' : '')}
                                            />
                                            {actionItem && !isListSummary && (
                                                <Tooltip text={actionItem.label} position="top">
                                                    <button onClick={actionItem.action} className="p-1.5 text-gray-400 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg transition-colors flex-shrink-0">
                                                        <actionItem.icon className="w-4 h-4" />
                                                    </button>
                                                </Tooltip>
                                            )}
                                        </div>
                                        {isListSummary ? (
                                            <button onClick={() => setActiveFormat('grid')} className="p-1.5 text-gray-400 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg"><TableCellsIcon className="w-4 h-4" /></button>
                                        ) : (
                                            <Tooltip text="Explain extraction logic" position="left">
                                                <button onClick={() => triggerExplanation(key, String(value))} className="p-1.5 text-gray-400 hover:text-amber-500 hover:bg-amber-50 dark:hover:bg-amber-900/20 rounded-lg opacity-0 group-hover:opacity-100 focus:opacity-100 transition-all"><LightBulbIcon className="w-4 h-4" /></button>
                                            </Tooltip>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                );
            case 'grid':
                if (tables.length === 0) return <div className="flex flex-col items-center justify-center h-full text-gray-500"><TableCellsIcon className="w-12 h-12 mb-3 opacity-20" /><p>No table structures detected.</p></div>;
                const currentTable = tables[activeTableIndex] || tables[0];
                if (!currentTable || !currentTable.data || currentTable.data.length === 0) return <div className="p-6 text-center text-gray-500">Empty table data.</div>;
                const keys = Object.keys(currentTable.data[0]);
                const filteredRows = currentTable.data.filter((row, i) => {
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        if (!Object.values(row).some(v => String(v).toLowerCase().includes(q))) return false;
                    }
                    return true;
                });
                if (filteredRows.length === 0) return <div className="p-12 text-center text-gray-500 font-medium">No matching rows found.</div>;
                return (
                    <div className="flex flex-col h-full overflow-hidden">
                        <div className="flex-shrink-0 flex items-center justify-between px-6 py-3 border-b border-black/5 dark:border-white/5 bg-gray-50/50 dark:bg-zinc-800/50">
                            <div className="flex space-x-1 overflow-x-auto ios-scroll no-scrollbar">
                                {tables.length > 1 ? tables.map((t, i) => (
                                    <button key={i} onClick={() => setActiveTableIndex(i)} className={`px-3 py-1.5 text-xs font-bold rounded-lg transition-all whitespace-nowrap ${activeTableIndex === i ? 'bg-white dark:bg-zinc-700 text-[#007AFF] shadow-sm' : 'text-gray-500 hover:bg-black/5'}`}>{t.name}</button>
                                )) : <span className="text-xs font-bold text-gray-500 uppercase tracking-widest">{currentTable.name}</span>}
                            </div>
                            <button onClick={() => exportTableToCSV(currentTable)} className="p-1.5 text-gray-500 hover:text-[#007AFF] hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg"><ArrowDownTrayIcon className="w-4 h-4" /></button>
                        </div>
                        <div className="flex-grow overflow-auto ios-scroll">
                            <table ref={tableRef} className="w-full text-left border-collapse min-w-[600px]">
                                <thead className="sticky top-0 bg-white dark:bg-zinc-900 z-10 shadow-sm">
                                    <tr className="border-b border-black/5 dark:border-white/5">{keys.map(k => <th key={k} className="p-4 text-xs font-bold uppercase tracking-widest text-gray-500 dark:text-gray-400 bg-gray-50/80 dark:bg-zinc-800/80 backdrop-blur-sm">{k}</th>)}</tr>
                                </thead>
                                <tbody>
                                    {filteredRows.map((row: any, i: number) => (
                                        <tr key={i} className="border-b border-black/5 dark:border-white/5 hover:bg-gray-50/50 dark:hover:bg-white/5">
                                            {keys.map(k => {
                                                const valStr = String(row[k] ?? '');
                                                const actionItem = getActionForValue(k, valStr);
                                                return (
                                                    <td key={k} className={`p-2 text-sm relative`}>
                                                        <div className="flex items-center gap-1 group/cell">
                                                            <div className="flex-1 min-w-0">
                                                                <EditableInput value={valStr} onChange={(e) => handleGridChange(i, k, e.target.value)} onBlur={(e) => handleInputBlur(k, e.target.value, i)} onFocus={() => { setActiveField(k); setShowSplitView(true); }} label={k} isActive={activeField === k} isEdited={editedFields.has(`${currentTable.path || 'root'}-${i}-${k}`)} />
                                                            </div>
                                                            {actionItem && (
                                                                <Tooltip text={actionItem.label} position="top">
                                                                    <button onClick={actionItem.action} className="p-1 text-gray-400 hover:text-blue-500 rounded-md opacity-0 group-hover/cell:opacity-100 focus:opacity-100 flex-shrink-0 transition-opacity">
                                                                        <actionItem.icon className="w-3.5 h-3.5" />
                                                                    </button>
                                                                </Tooltip>
                                                            )}
                                                            <Tooltip text="Explain" position="top">
                                                                <button onClick={() => triggerExplanation(k, valStr)} className="p-1 text-gray-400 hover:text-amber-500 hover:bg-amber-50 dark:hover:bg-amber-900/20 rounded-md opacity-0 group-hover/cell:opacity-100 focus:opacity-100 flex-shrink-0 transition-all"><LightBulbIcon className="w-3.5 h-3.5" /></button>
                                                            </Tooltip>
                                                        </div>
                                                    </td>
                                                );
                                            })}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            default: return null;
        }
    };

    return (
        <div className="flex flex-col h-full w-full">
            {notification && <Notification message={notification.message} type={notification.type} onClose={() => setNotification(null)} />}
            <ExplanationModal isOpen={isExplanationModalOpen} onClose={() => setIsExplanationModalOpen(false)} target={explanationTarget} explanation={explanationContent} isLoading={isExplanationLoading} />
            <SaveTemplateModal isOpen={isTemplateModalOpen} onClose={() => setIsTemplateModalOpen(false)} onSave={() => {}} />

            {/* Pane Header Group */}
            <div className="flex-shrink-0 bg-white/80 dark:bg-zinc-900/80 backdrop-blur-xl z-10 transition-colors duration-300 border-b border-black/5 dark:border-white/5">
                <div className="flex justify-between items-center p-4 pb-2">
                    <div>
                        <h2 className="text-xl font-extrabold tracking-tight text-[#1d1d1f] dark:text-white">Results</h2>
                        <p className="text-xs font-bold text-[#5856D6] dark:text-[#AF52DE] uppercase tracking-widest">{editedData.documentType}</p>
                    </div>
                    <div className="flex items-center gap-3">
                         {isSearchable && (
                            <>
                                {validationResult.issues.length > 0 && activeFormat === 'key_value' && (
                                    <button onClick={() => setShowOnlyIssues(!showOnlyIssues)} className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-bold transition-all border ${showOnlyIssues ? 'bg-red-50 text-red-700 dark:bg-red-900/30 dark:text-red-300 border-red-200 dark:border-red-800' : 'bg-black/5 dark:bg-white/5 text-gray-500 dark:text-gray-400 hover:bg-black/10 border-transparent'}`}>
                                        <ShieldCheckIcon className={`w-3.5 h-3.5 ${showOnlyIssues ? 'text-red-500' : ''}`} />
                                        <span>{showOnlyIssues ? 'Showing Issues' : `${validationResult.issues.length} Issues`}</span>
                                    </button>
                                )}
                                <div className="relative group/search">
                                    <MagnifyingGlassIcon className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400 group-focus-within/search:text-blue-500 transition-colors" />
                                    <input type="text" placeholder="Search fields..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="pl-9 pr-8 py-1.5 text-sm bg-gray-100 dark:bg-zinc-800 border-transparent focus:bg-white dark:focus:bg-black border focus:border-blue-500 rounded-lg outline-none transition-all w-48 focus:w-64 text-gray-800 dark:text-gray-200 placeholder-gray-500" />
                                    {searchQuery && (<button onClick={() => setSearchQuery('')} className="absolute right-2 top-1/2 -translate-y-1/2 p-0.5 rounded-full text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 hover:bg-black/5 dark:hover:bg-white/10"><XMarkIcon className="w-3.5 h-3.5" /></button>)}
                                </div>
                            </>
                        )}
                        {file.file.type.startsWith('image/') && (
                             <Tooltip text={showSplitView ? "Close Split View" : "Review with Split View"}>
                                <button onClick={() => setShowSplitView(p => !p)} className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-bold transition-all ${showSplitView ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/30' : 'bg-black/5 dark:bg-white/5 text-gray-500 dark:text-gray-400 hover:bg-black/10'}`}>
                                    <ViewColumnsIcon className="w-4 h-4" />
                                    <span className="hidden sm:inline">Split View</span>
                                </button>
                            </Tooltip>
                        )}
                    </div>
                </div>
                {/* Segmented Control Tabs */}
                <div className="px-4 pb-4">
                    <div className="flex p-1 bg-gray-100/80 dark:bg-zinc-800/80 backdrop-blur-md rounded-xl border border-black/5 dark:border-white/5">
                        {outputFormats.map(f => (
                             <button key={f.id} onClick={() => setActiveFormat(f.id)} className={`flex-1 py-2 text-xs font-bold rounded-lg transition-all duration-300 ${activeFormat === f.id ? 'bg-white dark:bg-zinc-700 text-[#007AFF] dark:text-[#0A84FF] shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'}`}>
                                {f.label}
                            </button>
                        ))}
                    </div>
                </div>
            </div>

            <div className="flex-grow flex overflow-hidden">
                <div className={`flex-1 flex flex-col overflow-hidden transition-all duration-300 ${showSplitView ? 'w-1/2 border-r border-black/5 dark:border-white/5' : 'w-full'}`}>
                    <div ref={resultsContentRef} className="flex-grow overflow-y-auto ios-scroll p-6 space-y-8 bg-transparent">
                        {settings.showSummary && <div className="animate-summary"><AISummary summary={summary} loading={isSummaryLoading} onRegenerate={handleRegenerateSummary} onExplain={handleExplainSummary} /></div>}
                        
                        <div className="border border-black/5 dark:border-white/5 rounded-2xl overflow-hidden min-h-[400px] bg-white/40 dark:bg-zinc-800/40 backdrop-blur-sm">
                           <div key={activeFormat} className="h-full w-full animate-fade-in">
                                {renderData(activeFormat, editedData)}
                           </div>
                        </div>

                        <div className="mt-8 pt-4 pb-2 border-t border-dashed border-gray-200 dark:border-zinc-700 flex justify-end opacity-60 hover:opacity-100 transition-opacity select-none">
                            <span className="text-[10px] font-mono text-gray-400 dark:text-zinc-500 uppercase tracking-widest">
                                {WATERMARK_TEXT}
                            </span>
                        </div>
                        <div className="h-4" /> {/* Reduced bottom padding as footer is removed */}
                    </div>
                </div>
                {showSplitView && (
                    <div className="w-1/2 bg-gray-50/50 dark:bg-black/20 flex flex-col overflow-hidden animate-fade-in backdrop-blur-sm">
                        <div className="flex items-center justify-between p-3 border-b border-black/5 dark:border-white/5 bg-white/50 dark:bg-zinc-800/50 backdrop-blur-md">
                            <span className="text-xs font-bold uppercase tracking-wider text-gray-500">Source Document</span>
                            <span className="text-[10px] text-gray-400">Click a field on left to zoom</span>
                        </div>
                        <div className="flex-grow relative overflow-hidden">
                            <DocumentHighlighter file={file} highlights={initialData.highlights || []} hoveredField={null} activeField={activeField} onHoverField={() => {}} showHighlights={true} />
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
};
